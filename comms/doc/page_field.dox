/// @page page_field_tutorial Fields Definition Tutorial
/// @tableofcontents
/// Fields are abstractions around value storage primitives and/or objects, 
/// such as integral values, floating point values, strings, arrays, etc..
/// Every @b field class is defined in @ref comms::field namespace and 
/// exposes predefined interface in order to
/// make template meta-programming as easy as possible. As an example let's
/// take a look at @ref comms::field::IntValue class which is used to 
/// define integral value field.
/// @code
/// template <typename TBase, typename T, typename... TOptions>
/// class comms::field::IntValue : public TBase
/// {
/// public:
///     // Define inner storage type
///     using ValueType = T;
///
///     // Type used for version update
///     using VersionType = typename TBase::VersionType;
///     
///     // Get access to the stored value
///     ValueType& value() { return m_value; }
///     const ValueType& value() const { return m_value; }
///
///     // Read
///     template <typename TIter>
///     comms::ErrorStatus read(TIter& iter, std::size_t len) {...}
///
///     // Write
///     template <typename TIter>
///     comms::ErrorStatus write(TIter& iter, std::size_t len) const {...}
///
///     // Serialisation length
///     std::size_t length() const {...}
///
///     // Validity of the value
///     bool valid() const {...}
///
///     // Bring field's contents into a consistent state
///     bool refresh() {...}
///
///     // Update protocol version
///     bool setVersion(VersionType value) {...}
///
///     // Compile time check whether the field's contents may change as the
///     // result of protocol version update
///     static constexpr bool isVersionDependent() {...};
///
/// private:
///     ValueType m_value;
/// }
/// @endcode
/// The main things to note are that every field definition class:
/// @li receives its base class as the first 
///     template parameter. It is expected to be a variant of @ref
///     comms::Field with @ref comms::option::def::BigEndian or @ref 
///     comms::option::def::LittleEndian option to specify the serialisation endian.
/// @li exhibits some default behaviour which can be modified by
///     passing various options from @ref comms::option namespace as additional template
///     parameters. All the available options are described below in this tutorial.
/// @li defines @b ValueType inner value storage
///     type and provides @b value() member functions to access the stored value.
/// @li provides @b read() and @b write() member functions to read and write the 
///     inner value given the iterator used for reading / writing and available
///     length of the buffer.
/// @li has @b length() member function to report how many bytes are required to
///     serialise currently stored value.
/// @li provides @b valid() member function to check whether the stored value is
///     valid (within expected range of values).
/// @li has @b refresh() member function to bring its contents to consistent / valid
///     state when required.
/// @li has @b setVersion() member function to notify field object that the
///     the protocol version has changed.
///
/// Also note that all the member function are NON-virtual, i.e. the field 
/// abstractions do not have polymorphic behaviour.
///
/// The available fields abstractions are:
/// @li @ref comms::field::IntValue - used to define @ref sec_field_tutorial_int_value
/// @li @ref comms::field::EnumValue - used to define @ref sec_field_tutorial_enum_value
/// @li @ref comms::field::BitmaskValue - used to define @ref sec_field_tutorial_bitmask_value
/// @li @ref comms::field::Bitfield - used to define @ref sec_field_tutorial_bitfield
/// @li @ref comms::field::Bundle - used to define @ref sec_field_tutorial_bundle
/// @li @ref comms::field::ArrayList - used to define @ref sec_field_tutorial_array_list
/// @li @ref comms::field::String - used to define @ref sec_field_tutorial_string
/// @li @ref comms::field::FloatValue - used to define @ref sec_field_tutorial_fp_value
/// @li @ref comms::field::Optional - used to define @ref sec_field_tutorial_optional
/// @li @ref comms::field::Variant - used to define @ref sec_field_tutorial_variant
///
/// @section sec_field_tutorial_int_value Integral Value Fields
/// Integral values are abstracted by comms::field::IntValue class, which
/// receives at least two template parameters. The first one is a base
/// class, from which the comms::field::IntValue will inherit. It must be
/// a variant of comms::Field, with the option specifying endian used for
/// data serialisation. The second template parameter is a basic integral type
/// that is used to store the field's value.@n
/// For example:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyIntField = comms::field::IntValue<MyFieldBase, std::int16_t>;
/// @endcode
/// The example above defines a field that uses @b std::int16_t type to store
/// its value. The value can be accessed using @b value() member function:
/// @code
/// MyIntField intField;
/// std::cout << "Default value: " << intField.value() << '\n'; // prints 0
/// intField.value() = 5;
/// std::cout << "Updated value: " << intField.value() << std::endl; // prints 5
/// @endcode 
/// When such field is serialised, 2 bytes (<b>sizeof(std::int16_t)</b>) are written
/// to the output buffer, most significant first and less significant second
/// (because @b MyFieldBase base class was defined using comms::option::def::BigEndian
/// option).
/// 
/// @subsection sec_field_tutorial_int_value_fixed_length Modifying Serialisation Length
/// Sometimes protocol specification tries to reduce amount of data transferred over
/// I/O link. It may define serialisation length of the field that differs
/// from standard length of basic integral types, such as @b std::int8_t, @b std::uint8_t,
/// @b std::int16_t, @b std::uint16_t, @b std::int32_t, @b std::uint32_t, ...
/// For example, some field may only have values between 0 and 10,0000,000, which
/// may be encoded using only 3 bytes, and that's what the protocol specifies.
/// The storage type for such value is going to be @b std::uint32_t, but there is
/// a need to limit serialisation length for it. The COMMS library provides
/// comms::option::def::FixedLength option, that can be used for this purpose.
/// @code
/// using MyIntField = comms::field::IntValue<MyFieldBase, std::uint32_t, comms::option::def::FixedLength<3> >;
/// @endcode
///
/// @subsection sec_field_tutorial_int_value_var_length Variable Serialisation Length
/// There are protocols, that try to reduce amount of traffic over I/O link by
/// using variable length when serialising numeric value. Usually it is
/// <a href="https://en.wikipedia.org/wiki/Variable-length_quantity">Base-128</a>
/// encoding, where the most significant bit in the byte indicates whether
/// it is the last byte in the numeric encoding or the next one also needs to
/// be taken into account. The COMMS library provides comms::option::def::VarLength
/// option that can be used with comms::field::IntValue and modifies the
/// behaviour of the latter to expose the required read()/write()/length() 
/// behaviour:
/// @code
/// // Variable length encoding, encoding takes at least 1 byte and at most 4 bytes. 
/// using MyIntField = comms::field::IntValue<MyFieldBase, std::uint32_t, comms::option::def::VarLength<1, 4> >;
/// @endcode
/// The field's base class (@b MyFieldBase) contains endian information which is
/// used to determine which part of the value is serialised first.
///
/// @subsection sec_field_tutorial_int_value_ser_offset Serialisation Offset
/// There are cases when there is a need to add/subtract some predefined offset
/// to/from the value of the field when serialisation takes place. 
/// Good example of such case would be serialising a "current year" value. 
/// Most protocols now specify it as an offset from year 2000 or later and 
/// serialised as a single byte, i.e. to specify year 2015 is to write value 15. 
/// However it may be inconvenient to manually adjust serialised/deserialised 
/// value by predefined offset 2000. To help with such case option 
/// comms::option::def::NumValueSerOffset can be used. For example:
/// @code
/// using YearField = 
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::int16_t, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::NumValueSerOffset<-2000>
///     >;
///
/// static const std::uint8_t SerData[] = { 15 }; // Pretend serialisation data
/// static const std::size_t SerDataLen = std::extent<decltype(SerData)>::value; 
/// 
/// YearField year;
/// auto* readIter = &SerData[0];
/// auto es = year.read(readIter, SerDataLen); // Read year information
/// assert(es == comms::ErrorStatus::Success); // No failure is expected
///
/// std::cout << year.value() << std::endl; // Prints 2015;
///
/// // Modify year value:
/// year.value() = 2016;
/// 
/// std::vector<std::uint8_t> outData; // Pretend output buffer
/// auto writeIter = std::back_inserter(outData);
/// es = year.write(writeIter, outData.max_size());
/// assert(es == comms::ErrorStatus::Success); // No failure is expected
///
/// assert(outData.size() == 1U); // Only 1 byte is expected to be pushed to outData,
///                               // due to using comms::option::def::FixedLength<1> option.
/// assert(outData[0] == 16); // The value equal to "year.value() - 2000" is expected to be written.  
/// @endcode
///
/// @subsection sec_field_tutorial_int_value_scaling Scaling Value
/// Sometimes systems operate with floating point numbers. Let's say to handle
/// the distance between two points on the map in meters. However, when communicating
/// this information over the I/O link, the developers often scale the floating
/// point value up in order to send such value as integer. For example, the distance
/// is communicated in millimeters (when calculated and handled in meters). 
/// The definition of such field may look like:
/// @code
/// using DistanceField =
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t, 
///         comms::option::def::ScalingRatio<1, 1000> 
///     >;
/// @endcode
/// The comms::option::def::ScalingRatio option allows scaling of serialised value
/// (distance in mm) to handling value (distance in m) and vice versa:
/// @code
/// static const std::uint8_t InData[] = {0x3, 0xe8}; // Pretend input buffer, encoded 1000
/// static const std::size_t InDataSize = std::extent<decltype(InData)>::value;
/// 
/// DistanceField dist;
/// const auto* readIter = &InData[0];;
/// auto es = dist.read(readIter, InDataSize);
/// assert(es == comms::ErrorStatus::Success); // No error is expected
///
/// std::cout << "Distance in mm: " << dist.value() << '\n'; // Prints 1000
/// std::cout << "Distance in m: "  << dist.getScaled<float>() << std::endl; // Prints 1.0
///
/// dist.setScaled(2.3);
/// std::cout << "New distance in mm: " << dist.value() << std::endl; // Prints 2300
/// @endcode
///
/// The scaling may work in the opposite direction of increasing the number. For
/// example, the field contains number of @b tens of millimeters between two points.
/// It would be convenient to be able to convert it to proper millimeters number.
/// As the result the field can be defined as:
/// @code
/// using OtherDistanceField = 
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t, 
///         comms::option::def::ScalingRatio<10, 1> 
///     >;
/// @endcode
/// The @ref comms::option::def::ScalingRatio option allows scaling of serialised value
/// (distance in tens of mm) to handling value (distance in mm) and vice verse:
/// @code
/// static const std::uint8_t InData[] = {0x0, 0xf}; // Pretend input buffer, encoded 15
/// static const std::size_t InDataSize = std::extent<decltype(InData)>::value;
/// 
/// OtherDistanceField dist;
/// const auto* readIter = &InData[0];;
/// auto es = dist.read(readIter, InDataSize);
/// assert(es == comms::ErrorStatus::Success); // No error is expected
///
/// std::cout << "Distance in tens of mm: " << dist.value() << '\n'; // Prints 15
/// std::cout << "Distance in mm: "  << dist.getScaled<unisnged>() << std::endl; // Prints 150
///
/// dist.setScaled(500);
/// std::cout << "New distance in tens of mm: " << dist.value() << std::endl; // Prints 50
/// @endcode
///
/// Methods comms::field::IntValue::getScaled and comms::field::IntValue::setScaled
/// take into account scaling ratio provided (with @ref comms::option::def::ScalingRatio option)
/// to the comms::field::IntValue field. If such option wasn't used  
/// @b comms::option::def::ScalingRatio<1, 1> is assumed.
///
/// @subsection sec_field_tutorial_int_value_units Value Units
/// In addition to @ref sec_field_tutorial_int_value_scaling, the @b COMMS library
/// provides an ability to specify field's value units and perform conversion
/// between units of the same type. Let's get back to the same example of defining
/// distance between two point, but instead of providing scaling ratio directly,
/// the type of the units is specified.
/// @code
/// using DistanceField =
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t, 
///         comms::option::def::UnitsMillimeters
///     >;
/// @endcode
/// The @ref comms::option::def::UnitsMillimeters option specifies that field contains
/// distance in millimeters, which allows @b COMMS library provide proper 
/// conversion to other distance units when necessary:
/// @code
/// static const std::uint8_t InData[] = {0x3, 0xe8}; // Pretend input buffer, encoded 1000
/// static const std::size_t InDataSize = std::extent<decltype(InData)>::value;
/// 
/// DistanceField dist;
/// const auto* readIter = &InData[0];;
/// auto es = dist.read(readIter, InDataSize);
/// assert(es == comms::ErrorStatus::Success); // No error is expected
///
/// std::cout << "Original value: " << dist.value() << '\n'; // Prints 1000
/// std::cout << "Distance in mm: "  << comms::units::getMillimeters<unsigned>(dist) << std::endl; // Prints 1000
/// std::cout << "Distance in cm: "  << comms::units::getCentimeters<float>(dist) << std::endl; // Prints 100.0
/// std::cout << "Distance in m: "  << comms::units::getMeters<float>(dist) << std::endl; // Prints 1.0
///
/// comms::units::setCentimeters(dist, 5.5f);
/// std::cout << "New value: " << dist.value() << '\n'; // Prints 55
/// std::cout << "New distance in mm: "  << comms::units::getMillimeters<unsigned>(dist) << std::endl; // Prints 55
/// std::cout << "New distance in cm: "  << comms::units::getCentimeters<float>(dist) << std::endl; // Prints 5.5
/// std::cout << "New distance in m: "  << comms::units::getMeters<float>(dist) << std::endl; // Prints 0.055
/// @endcode
///
/// In the examples above the "units" specification may replace the "scaling" 
/// information. However, there are cases when it they may complement each other.
/// For example, the field contains "latitude" information in @b degrees but
/// multiplied by 10'000'000 to make integral value out of floating point.
/// @code
/// using LatField =
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::int32_t,
///         comms::option::def::ScalingRatio<1, 10000000>, 
///         comms::option::def::UnitsDegrees
///     >;
/// @endcode
/// The @b COMMS library uses the scaling ratio as well as units information to
/// be able to convert the stored value between degrees and radians when needed.
/// @code
/// LatField lat(123456789); // Encoded latitude of 12.3456789
/// std::cout << "Raw value: " << lat.value() << std::endl; // Prints 123456789
/// std::cout << "Lat in degrees: " << comms::units::getDegrees<double>(lat) << std::endl; // Prints 12.3456789
/// std::cout << "Lat in radians: " << comms::units::getRadians<float>(lat) << std::endl; // 0.21547274519
///
/// comms::units::setDegrees(lat, 22.33);
/// std::cout << "New raw value: " << lat.value() << std::endl; // Prints 223300000
/// std::cout << "New degrees value: " << comms::units::getDegrees<double>(lat) << std::endl; // Prints 22.33
/// std::cout << "New radians value: " << comms::units::getRadians<double>(lat) << std::endl; // Prints 0.38973202
///
/// comms::units::setRadians(lat, 1.04719);
/// std::cout << "Updated raw value: " << lat.value() << std::endl; // Prints 600000000
/// std::cout << "Updated degrees value: " << comms::units::getDegrees<double>(lat) << std::endl; // Prints 60
/// std::cout << "Updated radians value: " << comms::units::getRadians<double>(lat) << std::endl; // Prints 1.04719
/// @endcode
/// The @b COMMS library provides mulitple @b options to specify the units of 
/// the field's value:
/// @li @b Time:
///     - @ref comms::option::def::UnitsNanoseconds
///     - @ref comms::option::def::UnitsMicroseconds
///     - @ref comms::option::def::UnitsMilliseconds
///     - @ref comms::option::def::UnitsSeconds
///     - @ref comms::option::def::UnitsMinutes
///     - @ref comms::option::def::UnitsDays
///     - @ref comms::option::def::UnitsWeeks
/// @li @b Distance:
///     - @ref comms::option::def::UnitsNanometers
///     - @ref comms::option::def::UnitsMicrometers
///     - @ref comms::option::def::UnitsMillimeters
///     - @ref comms::option::def::UnitsCentimeters
///     - @ref comms::option::def::UnitsMeters
///     - @ref comms::option::def::UnitsKilometers
/// @li @b Speed:
///     - @ref comms::option::def::UnitsNanometersPerSecond
///     - @ref comms::option::def::UnitsMicrometersPerSecond
///     - @ref comms::option::def::UnitsMillimetersPerSecond
///     - @ref comms::option::def::UnitsCentimetersPerSecond
///     - @ref comms::option::def::UnitsMetersPerSecond
///     - @ref comms::option::def::UnitsKilometersPerSecond
///     - @ref comms::option::def::UnitsKilometersPerHour
/// @li @b Frequency:
///     - @ref comms::option::def::UnitsHertz
///     - @ref comms::option::def::UnitsKilohertz
///     - @ref comms::option::def::UnitsMegahertz
///     - @ref comms::option::def::UnitsGigahertz
/// @li @b Angle:
///     - @ref comms::option::def::UnitsDegrees
///     - @ref comms::option::def::UnitsRadians
/// @li @b Electrical @b Current:
///     - @ref comms::option::def::UnitsNanoamps
///     - @ref comms::option::def::UnitsMicroamps
///     - @ref comms::option::def::UnitsMilliamps
///     - @ref comms::option::def::UnitsAmps
///     - @ref comms::option::def::UnitsKiloamps
/// @li @b Electrical @b Voltage:
///     - @ref comms::option::def::UnitsNanovolts
///     - @ref comms::option::def::UnitsMicrovolts
///     - @ref comms::option::def::UnitsMillivolts
///     - @ref comms::option::def::UnitsVolts
///     - @ref comms::option::def::UnitsKilovolts
///
/// All the units conversion functions reside in comms::units namespace. @b NOTE,
/// that conversion can be applied only between the units of the same type. The
/// units compitability check is performed at compile time and the compilation 
/// will fail on attempt to set/get incompatible value, such as
/// setting/getting "seconds" to/from the field specified as containing millimeters.
///
/// The whole units conversion functionality can be useful in a client code,
/// that requires usage of particular unit types in its internal calculations. It
/// can use conversion functions without any need to know scaling ratio and/or
/// actual units of the field, the @b COMMS library will do all the necessary math
/// calculation to provide the requested value.
///
/// @subsection sec_field_tutorial_int_value_other Other Options
/// There multiple common options that are applicable to all the fields,
/// comms::field::IntValue included. Please refer to 
/// @ref sec_field_tutorial_common_options for more details.
///
/// @section sec_field_tutorial_enum_value Enum Value Fields
/// Sometimes it is more convenient to operate with enum types instead of 
/// integral values. For example, the custom protocol message carries information
/// of how to configure some external serial port, and one of the values is
/// the baud rate. In order not to impose too much overhead on I/O link, the
/// protocol developers decided to use single byte to indicate one standard baud
/// rate:
/// |Baud Rate | Serialisation Value|
/// |:--------:|:------------------:|
/// | 9600     | 0                  |
/// | 14400    | 1                  |
/// | 19200    | 2                  |
/// | 28800    | 3                  |
/// | 38400    | 4                  |
/// | 57600    | 5                  |
/// | 115200   | 6                  |
///
/// It would be more convenient to define enum type to operate with, instead of
/// using raw numbers.
/// @code
/// enum Baud : std::uint8_t // The underlying type should be explicitly specified
/// {
///     Baud_9600,
///     Baud_14400,
///     Baud_19200,
///     Baud_28800,
///     Baud_38400,
///     Baud_57600,
///     Baud_115200
/// };
///
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using BaudField = comms::field::EnumValue<MyFieldBase, Baud>;
///
/// BaudField baud;
/// ...
/// baud.value() = Baud_115200; // Set the value.
///
/// std::vector<std::uint8_t> outData; // Pretend output buffer
/// auto writeIter = std::back_inserter(outData);
/// auto es = baud.write(writeIter, outData.max_size());
/// assert(es == comms::ErrorStatus::Success); // No error is expected
/// assert(outData.size() == 1); // Single byte output is expected
/// assert(outData[0] == 6U); // Value 6 is expected to be written
/// @endcode
/// comms::field::EnumValue is very similar to comms::field::IntValue. The main
/// difference is using enum instead of integral type as a second template
/// parameter. The default serialisation length is determined by the underlying
/// type of the enum. That't why it is important to explicitly specify the
/// underlying type of the enum when defining it, and not leave this to the
/// compiler.
///
/// The comms::field::EnumValue field supports almost all the options that
/// can be used with comms::field::IntValue: @ref sec_field_tutorial_int_value_fixed_length,
/// @ref sec_field_tutorial_int_value_var_length, @ref sec_field_tutorial_int_value_ser_offset,
/// as well as @ref sec_field_tutorial_common_options.
///
/// @section sec_field_tutorial_bitmask_value Bitmask Value Fields
/// Quite often messages in communication protocol use some kind of flags, where
/// single bit has a independent meaning. It is more convenient to treat
/// such flags as bitmasks rather than integral values. comms::field::BitmaskValue
/// provides a convenient interface to handle such bitmasks.
/// @code
/// using BitmaskField = comms::field::BitmaskValue<MyFieldBase>;
/// @endcode
/// By default the underlying storage type of the comms::field::BitmaskValue is
/// @b unsigned, which makes the default serialisation length to be 
/// @b sizeof(unsigned). The modification of the underlying storage type as
/// well as serialisation length can be done using comms::option::def::FixedLength
/// option (see @ref sec_field_tutorial_int_value_fixed_length). The underlying
/// type will always be some unsigned integral type. If the serialisation length
/// is specified to be 1 byte, the underlying storage type is @b std::uint8_t, 
/// if the serialisation length is 2 bytes, the underlying storage type is @b std::uint16_t,
/// if the serialisation length is 3 or 4 bytes, the underlying storage type is
/// @b std::uin32_t, etc...
/// @code
/// using BitmaskField_1byte = comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> >;
/// static_assert(std::is_same<BitmaskField_1byte::ValueType, std::uint8_t>::value, "std::uint8_t type is expected");
/// assert(BitmaskField_1byte().length() == 1U);
///
/// using BitmaskField_2bytes = comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<2> >;
/// static_assert(std::is_same<BitmaskField_2bytes::ValueType, std::uint16_t>::value, "std::uint16_t type is expected");
/// assert(BitmaskField_2bytes().length() == 2U);
///
/// using BitmaskField_3bytes = comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<3> >;
/// static_assert(std::is_same<BitmaskField_3bytes::ValueType, std::uint32_t>::value, "std::uint32_t type is expected");
/// assert(BitmaskField_2bytes().length() == 3U);
///
/// using BitmaskField_4bytes = comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<4> >;
/// static_assert(std::is_same<BitmaskField_4bytes::ValueType, std::uint32_t>::value, "std::uint32_t type is expected");
/// assert(BitmaskField_2bytes().length() == 4U);
/// @endcode
/// All the @ref sec_field_tutorial_common_options can also be used with 
/// comms::field::BitmaskValue.
///
/// @subsection sec_field_tutorial_bitmask_value_reserved Reserved Bits
/// Quite often the bitmask fields contain reserved bits, which must preserve
/// some values (usually 0). The comms::field::BitmaskValue fields support 
/// usage of @ref comms::option::def::BitmaskReservedBits alias option. The template
/// parameters of the option specify mask for reserved bits as well as their
/// expected values. The check for the reserved bits values is performed inside
/// @b comms::field::BitmaskValue::valid() member function.
/// @code
/// using MyBitmask = 
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x2, 0> // Second bit is reserved and must be 0
///     >;
/// @endcode
///
/// @subsection sec_field_tutorial_bitmask_value_names Bit Names
/// Quite often there is a need to provide names for the bits in the 
/// comms::field::BitmaskValue field. It is possible to define it as external
/// independent enum. However, it may be convenient to define it as internal
/// type. It is possible to do by inheriting from appropriate comms::field::BitmaskValue
/// type and use COMMS_BITMASK_BITS() macro to define names for bits. For example
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x2, 0> // Second bit is reserved and must be 0
///     >
/// {
///     COMMS_BITMASK_BITS(first, third=2, fourth, fifth, sixth, seventh, eighth);
/// }
/// @endcode
/// is equivalent to defining:
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x2, 0> 
///     >
/// {
///     enum BitIdx
///     {
///         BitIdx_first,
///         BitIdx_third=2,
///         BitIdx_fourth,
///         BitIdx_fifth,
///         BitIdx_sixth,
///         BitIdx_seventh,
///         BitIdx_eighth,
///         BitIdx_numOfValues,
///     }
/// }
/// @endcode
/// @b NOTE, that provided names have found their way to @b BitIdx enum type, and
/// got prefixed with @b BitIdx_. This indices may be used with 
/// comms::field::BitmaskValue::getBitValue() and comms::field::BitmaskValue::setBitValue()
/// member functions.
///
/// Also note, that there is automatically generated @b BitIdx_numOfValues 
/// value to indicate end of the names list.
///
/// Due to the fact that the provided bit names may have @b =val suffixes, it
/// excludes the ability to generate proper access functions for the named bits.
/// However, the @b COMMS library also provides @ref COMMS_BITMASK_BITS_ACCESS()
/// macro, which can be used in addition to @ref COMMS_BITMASK_BITS() one to
/// generate the convenience functions. For example:
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x2, 0> // Second bit is reserved and must be 0
///     >
/// {
///     COMMS_BITMASK_BITS(first, third=2, fourth, fifth, sixth, seventh, eighth);
///     COMMS_BITMASK_BITS_ACCESS(first, third, fourth, fifth, sixth, seventh, eighth);
/// }
/// @endcode
/// is equivalent to defining:
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x2, 0> 
///     >
/// {
///     enum BitIdx {...}
///
///     bool getBitValue_first() const { return getBitValue(BitIdx_first); }
///     void setBitValue_first(bool val) { setBitValue(BitIdx_first, val); }
///     bool getBitValue_third() const { ... }
///     void setBitValue_third(bool val) { ... }
///     bool getBitValue_fourth() const { ... }
///     void setBitValue_fourth(bool val) { ... }
///     ...
/// }
/// @endcode
/// In case the bit names definition is sequential starting with index 0 and
/// going up without and gaps, i.e. no @b =val suffixes are used, the usage of
/// two separate @ref COMMS_BITMASK_BITS() and @ref COMMS_BITMASK_BITS_ACCESS() macros,
/// can be unified into one @ref COMMS_BITMASK_BITS_SEQ():
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0xf0, 0> // 4 MSBs are reserved
///     >
/// {
///     COMMS_BITMASK_BITS_SEQ(first, second, third, fourth);
/// }
/// @endcode
/// <b style="color:red">WARNING:</b> Some compilers, such as @b clang or earlier
/// versions of @b gcc (v4.9 and earlier) may have problems compiling the 
/// @ref COMMS_BITMASK_BITS_ACCESS() and @ref COMMS_BITMASK_BITS_SEQ() macros
/// even though they contain valid C++11 code. If the compilation failure 
/// happens and the bitmask definition class is @b NOT a template one (like
/// in the example above), then try to substitute the used macros with
/// @ref COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE() and @ref COMMS_BITMASK_BITS_SEQ_NOTEMPLATE()
/// respectively. For example:
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0xf0, 0> // 4 MSBs are reserved
///     >
/// {
///     COMMS_BITMASK_BITS_SEQ_NOTEMPLATE(first, second, third, fourth);
/// }
/// @endcode
/// However, when the defined bitmask class is a template, then the inner
/// definition of @b Base type, which specifies the exact type of the base
/// class, is required. For example:
/// @code
/// template <typename... TExtraOptions>
/// class MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0xf0, 0>, // 4 MSBs are reserved
///         TExtraOptions...
///     >
/// {
///     // Duplicate base class type
///     using Base = 
///         comms::field::BitmaskValue<
///             MyFieldBase, 
///             comms::option::def::FixedLength<1>,
///             comms::option::def::BitmaskReservedBits<0xf0, 0>, // 4 MSBs are reserved
///             TExtraOptions...
///         >;
/// public:
///     COMMS_BITMASK_BITS_SEQ(first, second, third, fourth);
/// }
/// @endcode
/// The same goes for COMMS_BITMASK_BITS_ACCESS() macro.
///
/// @b NOTE, that @b COMMS library also defines @b COMMS_MUST_DEFINE_BASE in
/// case the base class definition is needed (going to be used). If the developed
/// application is going to be multi-platform and compiled with various compilers
/// (some of which may warn about unused private type) it is possible to use 
/// the defined symbol to add / remove the definition of the @b Base member type.
/// @code
/// template <typename... TExtraOptions>
/// class MyBitmask : public comms::field::BitmaskValue<...>
/// {
/// #ifdef COMMS_MUST_DEFINE_BASE
///     using Base = ...;
/// #endif
/// public:
///     COMMS_BITMASK_BITS_SEQ(first, second, third, fourth);
/// }
/// @endcode
///
/// @section sec_field_tutorial_bitfield Bitfield Fields
/// Many communication protocols try to pack multiple independent values into
/// a one or several bytes to save traffic on I/O link. For example, to encode
/// baud rate from example in @ref sec_field_tutorial_enum_value section, only 
/// 3 bits are needed (values [0 - 6]). The serial port configuration may
/// also require parity information, which may have only "None", "Even", and "Odd"
/// values:
/// |Parity    | Serialisation Value|
/// |:--------:|:------------------:|
/// | None     | 0                  |
/// | Odd      | 1                  |
/// | Even     | 2                  |
///
/// @code
/// enum Parity : std::uint8_t
/// {
///     Parity_None,
///     Parity_Odd,
///     Parity_Even
/// };
/// @endcode
/// To encode parity value only 2 bits are needed. Together with the baud mentioned
/// earlier, these two values will consume only 5 bits. Let's also use
/// the remaining 3 bits to complete a single byte as some kind of flags.
///
/// | Value    | Number of bits |
/// |:--------:|:--------------:|
/// | Baud     | 3              |
/// | Parity   | 2              |
/// | Flags    | 3              |
///
/// These value must be accessed and treated as independent values. However, they
/// must be bundled into a single byte when serialisation happens. The
/// COMMS library provides comms::field::Bitfield field for this purpose.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using SerialConfigField = 
///     comms::field::Bitfield<
///         MyFieldBase, 
///         std::tuple<
///             comms::field::EnumValue<MyFieldBase, Baud, comms::option::def::FixedBitLength<3> >,
///             comms::field::EnumValue<MyFieldBase, Parity, comms::option::def::FixedBitLength<2> >,
///             comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedBitLength<3> >
///         >
///     >;
/// @endcode
/// Please pay attention to the following details:
/// @li The bitfield members are bundled in 
///     <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>
///     and passed as the second template parameter.
/// @li The serialisation length of every bitfield member is specified in bits using
///     @ref comms::option::def::FixedBitLength (note difference to @ref comms::option::def::FixedLength
///     that specifies length in bytes).
/// @li The summary of all the "bit" lengths of all the members must be divisible
///     by 8, i.e. to be packed in any number of bytes without leaving a single
///     bit undefined.
/// @li The member of the bitfield may be any numeric field (comms::field::IntValue,
///     comms::field::EnumValue, and comms::field::BitmaskValue), that support
///     @ref comms::option::def::FixedBitLength option.
/// 
/// Every member of the bitfield may use all the supported options. The 
/// comms::field::Bitfield itself may receive only options listed in its class
/// description.
///
/// To get an access to the member fields use @b value() member function:
/// @code
/// SerialConfigField serialConfigField;
/// ...
/// auto& members = serialConfigField.value(); // Reference to the stored tuple of field members
/// auto& buadField = std::get<0>(members); // Reference to the baud field;
/// auto& parityField = std::get<1>(members); // Reference to the parity field;
/// auto& flagsField = std::get<2>(members); // Reference to the flags field
///
/// baudField.value() = Baud_115200; // =6
/// parityField.value() = Parity_Even; // =2
/// flagsField.value() = 0x2;
/// 
/// std::vector<std::uint8_t> outData; // Pretend output buffer
/// auto writeIter = std::back_inserter(outData);
/// auto es = baud.write(writeIter, outData.max_size());
/// assert(es == comms::ErrorStatus::Success); // No error is expected
/// assert(outData.size() == 1); // Single byte output is expected
/// assert(outData[0] == 0x56); // Binary value split to 3-2-3 bits: 010|10|110
/// @endcode
///
/// It would be convenient to access the member fields by name, rather than
/// by index with <a href="http://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>.
/// It can be achieved by using
/// COMMS_FIELD_MEMBERS_NAMES() macro inside field definition class.
/// @code
/// class SerialConfigField : public comms::field::Bitfield<...>
/// {
///     // (Re)definition of the base class as inner Base type is
///     // the requirement of @ref COMMS_FIELD_MEMBERS_NAMES() macro
///     using Base = comms::field::Bitfield<...>
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(baud, parity, flags);
/// }
/// @endcode
/// It is equivalent to having the following enum, types and functions defined:
/// @code
/// class SerialConfigField : public comms::field::Bitfield<...>
/// {
/// public:
///     // Access indices for member fields
///     enum FieldIdx {
///         FieldIdx_baud,
///         FieldIdx_parity,
///         FieldIdx_flags,
///         FieldIdx_numOfValues
///     };
/// 
///     // Accessor to "baud" field
///     auto field_baud() -> decltype(std::get<FieldIdx_baud>(value()))
///     {
///         return std::get<FieldIdx_baud>(value());
///     }
///
///     // Accessor to const "baud" field
///     auto field_baud() const -> decltype(std::get<FieldIdx_baud>(value()))
///     {
///         return std::get<FieldIdx_baud>(value());
///     }
///
///     // Accessor to "parity" field
///     auto field_parity() -> decltype(std::get<FieldIdx_parity>(value()))
///     {
///         return std::get<FieldIdx_parity>(value());
///     }
///
///     // Accessor to const "parity" field
///     auto field_parity() const -> decltype(std::get<FieldIdx_parity>(value()))
///     {
///         return std::get<FieldIdx_parity>(value());
///     }
///
///     // Accessor to "flags" field
///     auto field_flags() -> decltype(std::get<FieldIdx_flags>(value()))
///     {
///         return std::get<FieldIdx_flags>(value());
///     }
///
///     // Accessor to const "flags" field
///     auto field_flags() const -> decltype(std::get<FieldIdx_flags>(value()))
///     {
///         return std::get<FieldIdx_flags>(value());
///     }
///
///     // Redefinition of the members fields types:
///     using Field_baud = ...;
///     using Field_parity = ...;
///     using Field_flags = ...;
/// };
/// @endcode
/// @b NOTE, that provided names @b baud, @b parity, and @b flags, have
/// found their way to the following definitions:
/// @li @b FieldIdx enum. The names are prefixed with @b FieldIdx_. The
///     @b FieldIdx_nameOfValues value is automatically added at the end.
/// @li Accessor functions prefixed with @b field_
/// @li Types of member fields prefixed with @b Field_*
///
/// As the result, the fields can be accessed using multiple ways:
/// For example using @b FieldIdx enum
/// @code
/// SerialConfigField field;
/// auto& members = field.value(); // get access to the std::tuple of member fields
/// auto& baudField = std::get<SerialConfigField::FieldIdx_baud>(members);
/// auto& parityField = std::get<SerialConfigField::FieldIdx_parity>(members);
/// auto& flagsField = std::get<SerialConfigField::FieldIdx_flags>(members);
///
/// auto baud = baudField.value();
/// auto parity = parityField.value();
/// auto flags = flagsField.value();
/// @endcode
/// or using accessor functions:
/// @code
/// SerialConfigField field;
/// auto baud = field.field_baud().value();
/// auto parity = field.field_parity().value();
/// auto flags = field.flags.value();
/// @endcode
/// <b>SIDE NOTE:</b> In addition to @ref COMMS_FIELD_MEMBERS_NAMES() macro
/// there is @ref COMMS_FIELD_MEMBERS_ACCESS() one. It is very similar to
/// @ref COMMS_FIELD_MEMBERS_NAMES() but does @b NOT (re)define the inner @b Field_*
/// types. It also does not require (except for @b clang) having base class to
/// be (re)defined as inner @b Base type.
/// @code
/// class SerialConfigField : public comms::field::Bitfield<...>
/// {
/// public:
///     COMMS_FIELD_MEMBERS_ACCESS(baud, parity, flags);
/// }
/// @endcode
/// In fact @ref COMMS_FIELD_MEMBERS_NAMES() is implemented as the wrapper 
/// around @ref COMMS_FIELD_MEMBERS_ACCESS().
///     
/// @section sec_field_tutorial_bundle Bundle Fields
/// There are cases when multiple independent fields need to be bundled into
/// a single field and expose the required interface of reading, writing,
/// calculating length, checking field's contents validity, and bringing field's
/// value into a consistent state. It may be required
/// when a message contains sequence (see @ref sec_field_tutorial_array_list) 
/// of such bundles/structs. The COMMS library provides comms::field::Bundle
/// field for this purpose. It is quite similar to comms::field::Bitfield described
/// earlier. The difference is that every member field
/// doesn't specify any length in bits, just bytes. For example:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
///
/// enum SomeEnum : std::uint8_t
/// {
///     SomeEnum_Value1,
///     SomeEnum_Value2,
///     SomeEnum_Value3,
///     ...
/// }
///
/// using MyBundle =
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::IntValue<MyFieldBase, std::int16_t> // 2 bytes int value
///             comms::field::EnumValue<MyFieldBase, SomeEnum>, // 1 byte enum value
///             comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> > // 1 byte bitmask
///         >
///     >;
///
/// MyBundle bundleField;
/// ...
/// auto& members = bundleField.value(); // Reference to the stored tuple of field members
/// auto& intValueField = std::get<0>(members);
/// auto& enumValueField = std::get<1>(members);
/// auto& bitmaskValueField = std::get<2>(members);
///
/// intValueField.value() = ...; // access the value of IntValue member field.
/// enumValueField.value() = ...; // access the value of EnumValue member field.
/// bitmaskValueField.value() = ...; // access the value of BitmaskValue member field.
///
/// std::vector<std::uint8_t> outData; // Pretend output buffer
/// auto writeIter = std::back_inserter(outData);
/// auto es = baud.write(writeIter, outData.max_size());
/// assert(es == comms::ErrorStatus::Success); // No error is expected
/// assert(outData.size() == 4); // Expected 2 bytes for IntValue, 1 byte for EnumValue and 1 byte for BitmaskValue
/// @endcode 
/// The default behaviour of comms::field::Bundle may be extended with options.
/// Please refer to the class documentation for the list of supported options.
///
/// Just like with the @ref sec_field_tutorial_bitfield, the names to the
/// member fields can be provided by using @ref COMMS_FIELD_MEMBERS_NAMES() or
/// @ref COMMS_FIELD_MEMBERS_ACCESS() macro.
/// @code
/// class MyBundle : public comms::field::Bundle<...>
/// {
///     // (Re)definition of the base class as inner Base type is
///     // required by COMMS_FIELD_MEMBERS_NAMES() macro. 
///     using Base = comms::field::Bundle<...>;
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(member1, member2, member3);
/// };
/// @endcode
/// It will create similar enum and convenience access functions, just
/// like described in previous @ref sec_field_tutorial_bitfield section.
///
/// Some @b bundle fields in some protocols may contain a field, which 
/// holds a <b>remaining serialization length</b> of the following member fields
/// in the bundle. The @b COMMS library has a built-in support for such cases,
/// it requires usage of @ref comms::option::def::RemLengthMemberField option to
/// specify index of such field. For example:
/// @code
/// template <typename... TExtraOptions>
/// class MyBundle : public
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::IntValue<FieldBase, std::uint8_t>, // remaing length info
///             SomeField1, 
///             SomeField2, 
///             SomeField3
///         >,
///         comms::option::def::RemLengthMemberField<0>, // Index of the remaining length field is 0
///         TExtraOptions...
///     >
/// {
///     using Base = ...;
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(length, f1, f2, f3);
/// };
/// @endcode
///
/// @section sec_field_tutorial_array_list Array List Fields
/// Some communication protocols may define messages that transmit sequence
/// of similar fields and/or raw data buffers. To make it easier to handle, the
/// COMMS library provides comms::field::ArrayList field which provide a required
/// interface to properly handle such sequences of data. It supports a
/// sequence of raw bytes
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MySimpleList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         std::uint8_t
///     >;
/// @endcode
/// as well as using sequence of any fields defined in comms::field namespace
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyComplexList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         MyBundle<> // Complex bundle field, defined in previous section 
///     >;
/// @endcode
/// By default the read operation on comms::field::ArrayList continues as
/// long as there is data left in input buffer, and write operation serialises
/// all the data stored in internal vector. These default behaviours can be 
/// changed using options described below.
///
/// @subsection sec_field_tutorial_array_list_size_prefix Prefixing with Size Information
/// Very often variable size sequences of raw bytes or other fields get
/// prefixed with size information. The default behaviour of the 
/// comms::field::ArrayList is to read until the end of the buffer. Having
/// sequence prefixed with number of elements to follow, allows earlier
/// termination of the read operation, and allows having other independent
/// fields to be appended after the sequence. The comms::field::ArrayList
/// class supports @ref comms::option::def::SequenceSizeFieldPrefix option that allows
/// to specify type of the size field (usually a variant of comms::field::IntValue)
/// to be serialised before the contents of comms::field::ArrayList being
/// serialised. For example, the serialised raw bytes sequence is prefixed with
/// 2 bytes of size information: 
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
///
/// using SizePrefixField = comms::field::IntValue<MyFieldBase, std::uint16_t>;
///
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         std::uint8_t,
///         comms::option::def::SequenceSizeFieldPrefix<SizePrefixField>
///     >;
///
/// static const std::uint8_t InputBuffer[] = {
///     0x0, 0x3, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
/// }
/// static const auto InputBufferSize = std::extent<decltype(InputBuffer)>::value;
///
/// MyList myList;
/// const auto* readIter = &InputBuffer[0];
/// auto es = myList.read(readIter, InputBufferSize); 
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(myList.value().size() == 3U); // Reading only 3 elements
/// assert((myList.value())[0] == 0xa); // First element
/// assert((myList.value())[1] == 0xb); // Second element 
/// assert((myList.value())[2] == 0xc); // Third element
/// assert(std::distance(&InputBuffer[0], readIter) == 5); // Expected to consume 2 first bytes of the size + ,
///                                                        // number of elements size specified (=3). Overall 5 bytes consumed 
///
///
/// std::vector<std::uint8_t> outputBuffer;
/// auto writeIter = std::back_inserter(outputBuffer);
/// es = myList.write(writeIter, outputBuffer.max_size());
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(outputBuffer.size() == 5U); // Expected to write 5 bytes, 2 bytes for size, and 3 for elements.
/// assert(std::equal(outputBuffer.begin(), outputBuffer.end(), std::begin(InputBuffer)); // The output must be equal to
/// @endcode
/// 
/// Some protocols prefix the sequence with <b>serialisation length</b> rather
/// than <b>number of elements to follow</b>. In this case the 
/// @ref comms::option::def::SequenceSerLengthFieldPrefix option needs to be used
/// instead of @ref comms::option::def::SequenceSizeFieldPrefix.
///
/// @subsection sec_field_tutorial_array_list_elem_length_prefix Element Serialisation Length Prefix
/// Also some protocols, for easier exchange of lists between nodes that use 
/// different versions of the same protocol, may require prefixing <b>every
/// element</b> of the list with its serialisation length. In this case
/// @ref comms::option::def::SequenceElemSerLengthFieldPrefix option may be used.
/// For example, the list of bundles prefixed with 2 bytes specifying number of
/// elements to follow, and with every element prefixed with its serialisation length using
/// variable length base-128 encoding may look like this:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
///
/// using SizePrefixField = comms::field::IntValue<MyFieldBase, std::uint16_t>;
/// using ElemLengthPrefixField = 
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint32_t,
///         comms::option::def::VarLength<1, 4> // variable length encoding up to 4 bytes
///     >;
///
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         MyBundle, // some bundle of fields
///         comms::option::def::SequenceSizeFieldPrefix<SizePrefixField>,
///         comms::option::def::SequenceElemSerLengthFieldPrefix<ElemLengthPrefixField>
///     >;
/// @endcode
/// When every element of the list is of fixed size, i.e. has the same serialisation
/// length, it becomes redundant to prefix @b every element with its length.
/// Instead, only first element can be prefixed with one, and all others may 
/// reuse the same information. To achieve such behaviour 
/// @ref comms::option::def::SequenceElemFixedSerLengthFieldPrefix should be used instead.
/// For example, the list of <b>fixed length</b> bundles prefixed with 1 byte specifying number of
/// elements to follow, and with first element prefixed with 1 byte containing its serialisation length
/// may look like this:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
///
/// using SizePrefixField = comms::field::IntValue<MyFieldBase, std::uint8_t>;
/// using ElemLengthPrefixField = comms::field::IntValue<MyFieldBase, std::uint8_t>;
///
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         comms::field::Bundle<
///             MyFieldBase,
///             std::tuple<
///                 comms::field::IntValue<MyFieldBase, std::uint16_t>,
///                 comms::field::IntValue<MyFieldBase, std::uint8_t>
///             >
///         >,
///         comms::option::def::SequenceSizeFieldPrefix<SizePrefixField>,
///         comms::option::def::SequenceElemFixedSerLengthFieldPrefix<ElemLengthPrefixField>
///     >;
/// @endcode
///
/// @subsection sec_field_tutorial_array_list_detached_size_prefix Detached Size Information
/// There may be cases when size information is detached from the sequence itself, i.e.
/// there are other fields between the size field and the sequence itself. 
/// For example, the protocol specifies the following:
/// | Byte Offset | Length | Description |
/// |:-----------:|:------:|:-----------:|
/// | 0           | 1      | Number of elements in sequence |
/// | 1           | 1      | Some flags bitmask | 
/// | 2           | 2 * N  | Sequence of 2 byte integral values |
///
/// In this case the option @ref comms::option::def::SequenceSizeFieldPrefix can NOT
/// be used. In fact the size information is not a part of the sequence any
/// more, it must be a separate independent field. When this field
/// is successfully read, its value must be forced upon the sequence somehow
/// before the read operation of the sequence takes place. To help with such
/// forcing, @ref comms::option::def::SequenceSizeForcingEnabled option was introduced.
/// When this option used, the comms::field::ArrayList::forceReadElemCount member 
/// function of the field may be used to force number of elements that follow.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using SeqSizeField = comms::field::IntValue<MyFieldBase, std::uint8_t>;
/// using BitmaskField = comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> >;
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         comms::field::IntValue<MyFieldBase, std::uint16_t>,
///         comms::option::def::SequenceSizeForcingEnabled
///     >;
///
/// static const std::uint8_t InputBuffer[] = {
///     0x3, 0xff, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
/// }
/// static const auto InputBufferSize = std::extent<decltype(InputBuffer)>::value;
///
/// const auto* readIter = &InputBuffer[0];
/// auto remSize = InputBufferSize;
///
/// SeqSizeField sizeField;
/// auto es = sizeField.read(readIter, remSize); 
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(sizeField.value() == 3U); // First byte should be read;
/// 
/// remSize -= sizeField.length();
/// BitmaskField bitmask;
/// es = bitmask.read(readIter, remSize);
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(bitmask.value() == 0xff); // Second byte should be read;
///
/// remSize -= bitmask.length();
/// MyList myList;
/// myList.forceReadElemCount(sizeField.value()); // Force number of elements to read
/// es = myList.read(readIter, remSize);
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(myList.value().size() == 3U); // Reading only 3 elements
/// assert((myList.value())[0] == 0xa); // First element
/// assert((myList.value())[1] == 0xb); // Second element 
/// assert((myList.value())[2] == 0xc); // Third element
/// @endcode
///
/// @subsection sec_field_tutorial_array_list_force_element_size Forcing Element Serialisation Length
/// In addition to prefixing variable length lists with amount of elements to
/// follow, some protocols may also prefix them with serialisation
/// length of the <b>single element</b>. Such technique is usually used to
/// maintain data exchange compatibility with earlier versions of the protocol,
/// which may be used on the other side of the communication link. The @b COMMS
/// library allows forcing the serialisation length of a single element when
/// such information becomes available. It is similar to 
/// @ref sec_field_tutorial_array_list_detached_size_prefix. The option
/// @ref comms::option::def::SequenceElemLengthForcingEnabled needs to be used when
/// defining the field type, and @ref comms::field::ArrayList::forceReadElemLength()
/// and @ref comms::field::ArrayList::clearReadElemLengthForcing() functions to
/// set/clear the forcing information.
/// @code
/// // Common base class for all the fields
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
///
/// // Field used to serialise serialisation length of a single element in the list
/// using ElemLengthPrefixField = comms::field::IntValue<MyFieldBase, std::uint8_t>;
/// 
/// // Field used to serialise number of elements in the list
/// using SizePrefixField = comms::field::IntValue<MyFieldBase, std::uint8_t>;
///
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         comms::field::IntValue< // 3 bytes integers
///             MyFieldBas, 
///             std::uint32_t, 
///             comms::option::def::FixedLength<3> >,
///         comms::option::def::SequenceSizeFieldPrefix<SizePrefixField>, // 1 byte prefix
///         comms::option::def::SequenceElemLengthForcingEnabled // enable forcing of the element length
///     >;
///
/// static const std::uint8_t InputBuffer[] = {
///     0x4, // single element serialisation length
///     0x2, // number of elements in the list,
///     0xa, 0xa, 0xa, 0x0, // first element + padding 
///     0xb, 0xb, 0xb, 0x0 // second element + padding
/// }
/// static const auto InputBufferSize = std::extent<decltype(InputBuffer)>::value;
///
/// ElemLengthPrefixField lengthPrefix;
/// MyList myList;
/// const auto* readIter = &InputBuffer[0];
/// auto es = lengthPrefix(readIter, InputBufferSize);
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(lengthPrefix.value() == 4U);
///
/// myList.forceReadElemLength(lengthPrefix.value()); // force serialisation length of the single element
/// auto es = myList.read(readIter, InputBufferSize - lengthPrefix.length()); 
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(myList.value().size() == 2U); // Reading only 2 elements
/// assert((myList.value())[0] == 0x0a0a0a); // First element
/// assert((myList.value())[1] == 0x0b0b0b); // Second element 
/// assert(std::distance(&InputBuffer[0], readIter) == 10); // Expected to consume in the
/// @endcode
///
/// @subsection sec_field_tutorial_array_list_term_suffix Terminating Sequence with Suffix
/// Sometimes there is no information about size of the sequence up front. It
/// may be terminating using some kind of special value. For example, the
/// sequence of raw bytes is terminated by the value of 0. Such termination
/// is achieved by using @ref comms::option::def::SequenceTerminationFieldSuffix option.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using TermField = comms::field::IntValue<MyFieldBase, std::uint8_t>; // Default value is 0.
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         comms::field::IntValue<MyFieldBase, std::uint8_t>,
///         comms::option::def::SequenceTerminationFieldSuffix<TermField>
///     >;
///
/// static const std::uint8_t InputBuffer[] = {
///     0x1, 0x2, 0x3, 0x4, 0x0, 0xa, 0xb, 0xc
/// }
/// static const auto InputBufferSize = std::extent<decltype(InputBuffer)>::value;
///
/// const auto* readIter = &InputBuffer[0];
///
/// MyList myList;
/// es = myList.read(readIter, InputBufferSize);
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(myList.value().size() == 4U); // Reading only 4 elements, terminating 0 is not included
/// assert((myList.value())[0] == 0x1); // First element
/// assert((myList.value())[1] == 0x2); // Second element 
/// assert((myList.value())[2] == 0x3); // Third element
/// assert((myList.value())[4] == 0x4); // Fourth element
/// assert(std::distance(&InputBuffer[0], readIter) == 5); // Expected to consume all bytes including termination one 
/// @endcode
///
/// @subsection sec_field_tutorial_array_list_fixed_size Fixed Size Sequences
/// In many cases the size of the sequence is defined in the protocol without
/// any prefix or suffix to define the length of the sequence. To define
/// such sequence @ref comms::option::def::SequenceFixedSize option should be used.
/// Below is example of how to define sequence of four unsigned 16 bit integer
/// values.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         comms::field::IntValue<MyFieldBase, std::uint16_t>,
///         comms::option::def::SequenceFixedSize<4>
///     >;
///
/// static const std::uint8_t InputBuffer[] = {
///     0x0, 0x1, 0x0, 0x2, 0x0, 0x3, 0x0, 0x4, 0xa, 0xb, 0xc
/// }
/// static const auto InputBufferSize = std::extent<decltype(InputBuffer)>::value;
///
/// const auto* readIter = &InputBuffer[0];
///
/// MyList myList;
/// es = myList.read(readIter, InputBufferSize);
/// assert(es == comms::ErrorStatus::Success); // No error is expected;
/// assert(myList.value().size() == 4U); // Reading only 4 elements
/// assert((myList.value())[0] == 0x1); // First element
/// assert((myList.value())[1] == 0x2); // Second element 
/// assert((myList.value())[2] == 0x3); // Third element
/// assert((myList.value())[4] == 0x4); // Fourth element
/// assert(std::distance(&InputBuffer[0], readIter) == 8); // Consumed only 4 element (2 bytes each) 
/// @endcode
/// @b NOTE, that comms::option::def::SequenceFixedSize option insures existence of
/// the right number of elements "on the wire", but doesn't influence number
/// of elements in the newly created list field:
/// @code
/// MyList myList;
/// auto& storageVector = myList.value();
/// assert(storageVector.empty());
/// @endcode
/// Also nothing prevents from having too many values in the storage vector, but
/// only specified number of the elements will be serialised:
/// @code
/// myList.push_back(0x1); // will be serialised
/// myList.push_back(0x2); // will be serialised
/// myList.push_back(0x3); // will be serialised
/// myList.push_back(0x4); // will be serialised
/// myList.push_back(0x5); // WON'T be serialised
/// @endcode
///
/// @subsection sec_field_tutorial_array_list_storage Value Storage
/// By default, the internal data is stored using 
/// <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>.
/// @code
/// MySimpleList simpleList; // defined above
/// auto& simpleListStorage = simpleList.value(); // reference to std::vector<std::uint8_t>;
///
/// MyComplexList complexList; // defined above
/// auto& complexListStorage = complexList.value(); // reference to std::vector<MyBundle>;
/// @endcode
/// This behaviour can be modified using extra options such as @ref
/// comms::option::app::CustomStorageType, @ref comms::option::app::FixedSizeStorage, 
/// @ref comms::option::app::OrigDataView, or @ref comms::option::app::SequenceFixedSizeUseFixedSizeStorage.
/// @b HOWEVER, these options do not influence the way how list fields are being
/// serialised, they influence the way how list value has been stored. As the result,
/// they should @b NOT be used in protocol definition. Instead, provide a way to
/// to the actual application to modify the default storage by passing extra
/// options. For example:
/// @code
/// template <typename... TExtraOptions>
/// using MyList = comms::field::ArrayList<..., TExtraOptions...>;
/// @endcode
/// 
/// All the @ref sec_field_tutorial_common_options are also applicable to
/// comms::field::ArrayList field.
///
/// @section sec_field_tutorial_string String Fields
/// Many protocols have to transfer strings. They are defined using
/// @ref comms::field::String field.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyString = comms::field::String<MyFieldBase>;
/// @endcode
/// It is very similar to comms::field::ArrayList
/// it terms of value storage, read/write operations, and supported options.
/// By default the value is stored as 
/// <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>.
/// @code
/// MyString myStr;
/// auto& myStrStorage = myStr.value(); // Reference to std::string.
/// @endcode
/// Just like described in @ref sec_field_tutorial_array_list_storage section
/// above the same options can be used to modify the storage type of the 
/// comms::field::String field, but should @b NOT be used in protocol definition, but
/// instead there should be an ability to provide extra options.
/// @code
/// template <typename... TExtraOptions>
/// using MyString = comms::field::String<MyFieldBase, TExtraOptions...>;
/// @endcode
///
/// Prefixing string with single byte of the size information will look like this:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using SizePrefixField = comms::field::IntValue<MyFieldBase, std::uint8_t>;
/// using MyString = 
///     comms::field::String<
///         MyFieldBase, 
///         comms::option::def::SequenceSizeFieldPrefix<SizePrefixField> 
///     >;
///
/// MyString myStr;
/// myStr.value() = "hello";
///
/// std::vector<std::uint8_t> outputBuf;
/// auto writeIter = std::back_inserter(outputBuf);
/// auto es = myStr.write(writeIter, outputBuf.max_size());
/// assert(es = comms::ErrorStatus::Success); // No error is expected
/// assert(outputBuf.size() == 6U); // 1 byte of size, followed by 5 characters of "hello" string
/// assert(outputBuf[0] == 5U); // size info
/// assert(outputBuf[1] == 'h');
/// assert(outputBuf[2] == 'e');
/// assert(outputBuf[3] == 'l');
/// assert(outputBuf[4] == 'l');
/// assert(outputBuf[5] == 'o');
/// @endcode
/// See also @ref sec_field_tutorial_array_list_size_prefix.
///
/// Encoding of zero termination strings without size prefix can be defined like
/// this:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using ZeroTermField = comms::field::IntValue<MyFieldBase, std::uint8_t>; // default value is 0
/// using MyString = 
///     comms::field::String<
///         MyFieldBase, 
///         comms::option::def::SequenceTerminationFieldSuffix<ZeroTermField> 
///     >;
///
/// MyString myStr;
/// myStr.value() = "hello";
///
/// std::vector<std::uint8_t> outputBuf;
/// auto writeIter = std::back_inserter(outputBuf);
/// auto es = myStr.write(writeIter, outputBuf.max_size());
/// assert(es = comms::ErrorStatus::Success); // No error is expected
/// assert(outputBuf.size() == 6U); // 5 characters of "hello" string followed by zero termination suffix
/// assert(outputBuf[0] == 'h');
/// assert(outputBuf[1] == 'e');
/// assert(outputBuf[2] == 'l');
/// assert(outputBuf[3] == 'l');
/// assert(outputBuf[4] == 'o');
/// assert(outputBuf[5] == 0U);
/// @endcode
/// See also @ref sec_field_tutorial_array_list_term_suffix.
///
/// Another string example is to have zero terminated string, the serialisation
/// of which occupies exactly 32 bytes, i.e. the string may have up to 31 non-zero
/// characters. If string is too short, the serialisation data is padded by
/// zeros until full length of 32 characters is produced.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using ZeroTermField = comms::field::IntValue<MyFieldBase, std::uint8_t>; // default value is 0
/// using MyString = 
///     comms::field::String<
///         MyFieldBase, 
///         comms::option::def::SequenceFixedSize<31>,
///         comms::option::def::SequenceTrailingFieldSuffix<ZeroTermField> 
///     >;
///
/// MyString myStr;
/// myStr.value() = "hello";
///
/// std::vector<std::uint8_t> outputBuf;
/// auto writeIter = std::back_inserter(outputBuf);
/// auto es = myStr.write(writeIter, outputBuf.max_size());
/// assert(es = comms::ErrorStatus::Success); // No error is expected
/// assert(outputBuf.size() == 32); // 5 characters of "hello" string followed by zero padding
/// assert(outputBuf[0] == 'h');
/// assert(outputBuf[1] == 'e');
/// assert(outputBuf[2] == 'l');
/// assert(outputBuf[3] == 'l');
/// assert(outputBuf[4] == 'o');
/// assert(outputBuf[5] == 0U);
/// ...
/// assert(outputBuf[31] == 0U);  
/// @endcode
/// @b NOTE, that the example above uses @ref comms::option::def::SequenceTrailingFieldSuffix
/// option, rather than @ref comms::option::def::SequenceTerminationFieldSuffix.
/// The options slightly differ. The "termination" one 
/// (@ref comms::option::def::SequenceTerminationFieldSuffix) forces the field to
/// stop reading when termination value is encountered, while "trailing" one
/// (@ref comms::option::def::SequenceTrailingFieldSuffix) doesn't check what it reads,
/// the reading size must be limited by other means (@ref comms::option::def::SequenceFixedSize
/// in the example above). When the read is complete, it just consumes the
/// termination character. Both options, however, force the termination
/// character to be appended at the end during write operation. @n
/// <b>Also note</b>, that size limit is specified (using @ref comms::option::def::SequenceFixedSize)
/// to be 31. One more byte is added by the "trailing" suffix to complete to 32
/// bytes.
///
/// Just like with @ref comms::field::ArrayList, it is possible to use static
/// storage for fixed size strings:
/// @code
/// using MyString = 
///     comms::field::String<
///         ..., 
///         comms::option::def::SequenceFixedSize<16>,
///         comms::option::app::SequenceFixedSizeUseFixedSizeStorage 
///     >;
/// @endcode
/// or 
/// @code
/// using MyString = 
///     comms::field::String<
///         ..., 
///         comms::option::def::SequenceFixedSize<16>,
///         comms::option::app::FixedSizeStorage<16> 
///     >;
/// @endcode
/// HOWEVER, the @ref comms::option::app "app" options should be used in protocol
/// definition, only in application customization.
///
/// @section sec_field_tutorial_fp_value Floating Point Value Fields
/// Floating point value fields (comms::field::FloatValue) are very similar to 
/// @ref sec_field_tutorial_int_value, but use @b float or @b double as its 
/// internal storage type. They abstract the IEEE 754 floating point 
/// values, which are serialised "as is" with either big or little endian
/// encoding. The floating point value fields also support 
/// @ref sec_field_tutorial_int_value_units conversions.
///
/// @section sec_field_tutorial_optional Optional Fields
/// Some protocols may define optional fields, which may exist or be missing
/// based on information recorded in other fields. For example there is a
/// "flags" bitmask field which specifies whether the following field exists or
/// missing. The optional field may also be tentative, i.e. if there is enough
/// data in the input buffer it exists, and missing otherwise. The COMMS
/// library provides comms::field::Optional which is a mere wrapper around
/// other fields and provides an ability to set the optional state of the field.
/// Let's do the example of the int32 field existence based on bit 0 in processing bitmask: 
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using FlagsField = comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> >;
/// using OptField = 
///     comms::field::Optional<
///         comms::field::IntValue<MyFieldBase, std::int32_t>
///     >;
///
/// FlagsField flags;
/// OptField optField;
/// 
/// // Common read function for multiple buffers
/// auto readFunc = 
///     [&flags, &optField](const std::uint8_t*& iter, std::size_t len)
///     {
///         auto es = flags.read(iter, len);
///         assert(es == comms::ErrorStatus::Success); // No error is expected;
/// 
///         optField.setMissing();
///         if ((flags.value() & 0x1) != 0) {
///             optField.setExists();
///         }
///
///         es = optField.read(iter, len - flags.length());
///         assert(es == comms::ErrorStatus::Success); // No error is expected;
///     };
///         
///
/// static const std::uint8_t InputBuffer1[] = {
///     0x1, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
/// }
/// static const auto InputBuffer1Size = std::extent<decltype(InputBuffer1)>::value;
///
/// auto* readIter = &InputBuffer1[0];
/// readFunc(readIter, InputBuffer1Size);
/// assert(std::distance(&InputBuffer1[0], readIter) == 5); // Expected to read 1 byte of flags and
///                                                         // 4 bytes of int32_t int value, because
///                                                         // bit 0 in flags is set.
/// assert(optField.field().value() == 0x0a0b0c0d); // value is expected to be updated;
///
///
///
/// static const std::uint8_t InputBuffer2[] = {
///     0x0, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
/// }
/// static const auto InputBuffer2Size = std::extent<decltype(InputBuffer2)>::value;
///
/// optField.field().value() = 0;
/// readIter = &InputBuffer2[0];
/// readFunc(readIter, InputBuffer2Size);
/// assert(std::distance(&InputBuffer2[0], readIter) == 1); // Expected to read only 1 byte of flags 
///                                                         // skipping read of int32_t int value, because
///                                                         // bit 0 in flags is cleared.
/// assert(optField.field().value() == 0); // value is expected NOT to be updated;
/// @endcode 
/// Note, that default mode for the optional field is "tentative", which is
/// updated after read operation:
/// @code
/// OptField optField1;
/// assert(optField1.getMode() == comms::field::OptionalMode::Tentative); // Default mode is tentative
/// 
/// static const std::uint8_t InputBuffer[] = {
///     0x11, 0x22, 0x33, 0x44
/// }
/// static const auto InputBufferSize = std::extent<decltype(InputBuffer)>::value;
///
/// auto* readIter = &InputBuffer[0];
/// auto es = optField1.read(readIter, InputBufferSize);
/// assert(es = comms::ErrorStatus::Success);
/// assert(std::distance(&InputBuffer[0], readIter) == 4); // Expected to read 4 bytes of int32_t int value
/// assert(optField1.getMode() == comms::field::OptionalMode::Exists); // Mode is changed
///
/// OptField optField2;
/// assert(optField2.getMode() == comms::field::OptionalMode::Tentative); // Default mode is tentative
/// readIter = &InputBuffer[0];
/// es = optField2.read(readIter, 0); // Note 0 as a buffer size
/// assert(es = comms::ErrorStatus::Success);
/// assert(std::distance(&InputBuffer[0], readIter) == 0); // Expected not to read anything
/// assert(optField2.getMode() == comms::field::OptionalMode::Missing); // Mode is changed
/// @endcode
/// It is easy to change the default mode of the comms::field::Optional field by
/// providing @ref comms::option::def::DefaultOptionalMode option with selected default mode
/// or @ref comms::option::def::MissingByDefault / @ref comms::option::def::ExistsByDefault aliases.
/// @code
/// using OptField = 
///     comms::field::Optional<
///         comms::field::IntValue<MyFieldBase, std::int32_t>,
///         comms::option::def::MissingByDefault // Set default mode to be "missing"
///     >;
/// @endcode
/// Some protocols may include version information either in transport framing or
/// in one of the messages. Such info may specify whether a specific field exists
/// or not. Such fields need to be wrapped in @ref comms::field::Optional field, which
/// receives @ref comms::option::def::ExistsBetweenVersions option to specify the
/// numeric versions of the protocol between which the field exists.
/// @code
/// using OptField = 
///     comms::field::Optional<
///         comms::field::IntValue<MyFieldBase, std::int32_t>,
///         comms::option::def::MissingByDefault, // Set default mode to be "missing"
///         comms::option::def::ExistsBetweenVersions<1, 5>
///     >;
/// @endcode
/// If the field has been introduced in one of the version, but hasn't been
/// removed yet, it is possible to use @ref comms::option::def::ExistsSinceVersion alias
/// to @ref comms::option::def::ExistsBetweenVersions. Or the opposite, if the field
/// has been introduced in the first version, but deprecated and removed in the 
/// later one, use @ref comms::option::def::ExistsUntilVersion alias.
///
/// Usage of such version control option will automatically mark the optional
/// field as @b existing or @b missing based on the provided version info in
/// the @b setVersion() member function.
///
/// @section sec_field_tutorial_variant Variant Fields
/// Some protocols may require usage of heterogeneous fields or lists of 
/// heterogeneous fields, i.e. the ones that can be of multiple types. Good example
/// would be a list of @b properties, where every property is a key/value pair or 
/// a TLV (type/length/value) triplet. The
/// key (or type) is usually a numeric ID of the property, while value can be any
/// field of any length. 
/// As an example for the key/value pairs let's define three value types:
/// @li Unsigned integer with length of only 1 byte (@b Value1)
/// @li Unsigned integer with length of 4 bytes (@b Value2)
/// @li String field with 1 byte size prefix (@b Value3)
///
/// The @b COMMS library provides comms::field::Variant field to allow such
/// heterogeneous fields. Let's implement the described example.
///
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using Value1 = comms::field::IntValue<MyFieldBase, std::uint8_t>;
/// using Value2 = comms::field::IntValue<MyFieldBase, std::uint32_t>;
/// using Value3 = 
///     comms::field::String<
///         MyFieldBase, 
///         comms::option::def::SequenceSizeFieldPrefix<
///             comms::field::IntValue<
///                 MyFieldBase,
///                 std::uint8_t
///             >
///         >
///     >;
/// @endcode
/// The common key type is easy to represent as enum.
/// @code
/// enum class KeyId : std::uint8_t
/// {
///     Key1,
///     Key2,
///     Key3,
///     NumOfValues
/// };
/// @endcode
/// And the relevant key fields as a variant of comms::field::EnumValue with
/// only single acceptable value.
/// @code
/// template <KeyId TId>
/// using KeyField =
///     comms::field::EnumValue<
///         MyFieldBase,
///         KeyId,
///         comms::option::def::DefaultNumValue<(int)TId>,
///         comms::option::def::ValidNumValueRange<(int)TId, (int)TId>,
///         comms::option::def::FailOnInvalid<>
///     >;
/// 
/// using Key1 = KeyField<KeyId::Key1>;
/// using Key2 = KeyField<KeyId::Key2>;
/// using Key3 = KeyField<KeyId::Key3>;
/// @endcode
/// Please pay attention to usage of @ref comms::option::def::FailOnInvalid option
/// and having only single valid value in order to force failure 
/// of the @b read operation when the key doesn't match.
///
/// Then the @b KeyX and its corresponding @b ValueX need to be bundled together
/// as a single @b PropertyX field.
/// @code
/// template <typename TKey, typename TValue>
/// class Property : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             TKey,
///             TValue
///         >
///     >
/// {
///     using Base = ...; // repeat base definition if needed
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(key, value);
/// };
///
/// using Property1 = Property<Key1, Value1>;
/// using Property2 = Property<Key2, Value2>;
/// using Property3 = Property<Key3, Value3>;
/// @endcode
/// Now we need a single @b field abstraction, which can be any of the specified
/// above forms. The comms::field::Variant field class provides such an ability.
/// As its second parameter it receives a tuple of supported types.
/// @code
/// class MyVariant : public 
///     comms::field::Variant<
///         MyFieldBase,
///         std::tuple<Property1, Property2, Property3>
///     >
/// {
///     // (Re)definition of the base class as inner Base type.
///     using Base = comms::field::Variant<...>;
/// public:
///     COMMS_VARIANT_MEMBERS_NAMES(prop1, prop2, prop3);
/// };
/// @endcode 
/// Similar to @ref COMMS_FIELD_MEMBERS_NAMES() macro for 
/// @ref sec_field_tutorial_bundle, the @ref COMMS_VARIANT_MEMBERS_NAMES()
/// macro generates the following convenience member enum and functions
/// @code
/// struct MyVariant : public comms::field::Variant<...>
/// {
///     // Enumerator to access fields 
///     enum FieldIdx {
///         FieldIdx_prop1,
///         FieldIdx_prop2,
///         FieldIdx_prop3,
///         FieldIdx_numOfValues
///     }
///
///     // Initialize internal storage as "prop1"
///     template <typename... TArgs>
///     auto initField_prop1(TArgs&&... args) -> decltype(initField<FieldIdx_prop1>(std::forward<TArgs>(args)...))
///     {
///         return initField<FieldIdx_prop1>(std::forward<TArgs>(args)...)
///     }
///
///     // Access internal storage already initialized as "prop1"
///     auto accessField_prop1() -> decltype(accessField<FieldIdx_prop1>())
///     {
///         return accessField<FieldIdx_prop1>();
///     }
///
///     // Access internal storage already initialized as "prop1" (const variant)
///     auto accessField_prop1() const -> decltype(accessField<FieldIdx_prop1>())
///     {
///         return accessField<FieldIdx_prop1>();
///     }
///
///     // Initialize internal storage as "prop2"
///     template <typename... TArgs>
///     auto initField_prop2(TArgs&&... args) -> decltype(initField<FieldIdx_prop2>(std::forward<TArgs>(args)...))
///     {
///         return initField<FieldIdx_prop2>(std::forward<TArgs>(args)...)
///     }
///
///     // Access internal storage already initialized as "prop2"
///     auto accessField_prop2() -> decltype(accessField<FieldIdx_prop2>())
///     {
///         return accessField<FieldIdx_prop2>();
///     }
///
///     // Access internal storage already initialized as "prop2" (const variant)
///     auto accessField_prop2() const -> decltype(accessField<FieldIdx_prop2>())
///     {
///         return accessField<FieldIdx_prop2>();
///     }
///
///     // Initialize internal storage as "prop3"
///     template <typename... TArgs>
///     auto initField_prop3(TArgs&&... args) -> decltype(initField<FieldIdx_prop3>(std::forward<TArgs>(args)...))
///     {
///         return initField<FieldIdx_prop3>(std::forward<TArgs>(args)...)
///     }
///
///     // Access internal storage already initialized as "prop3"
///     auto accessField_prop3() -> decltype(accessField<FieldIdx_prop3>())
///     {
///         return accessField<FieldIdx_prop3>();
///     }
///
///     // Access internal storage already initialized as "prop3" (const variant)
///     auto accessField_prop3() const -> decltype(accessField<FieldIdx_prop3>())
///     {
///         return accessField<FieldIdx_prop3>();
///     }
///
///     // Redefinition of the members fields types:
///     using Field_prop1 = ...;
///     using Field_prop2 = ...;
///     using Field_prop3 = ...;
/// };
/// @endcode
/// @b NOTE, that the provided names have propagated into definition of @b FieldIdx
/// enum, all @b initField_* and @b accessField_* functions, as well as
/// inner @b Field_* types definitions.
///
/// Now it is easy to put such @b Variant field type into the list:
/// @code
/// using PropertiesList = comms::field::ArrayList<MyFieldBase, MyVariant>;
/// @endcode
/// In this scenario, read operation on the list will invoke read operation of
/// every @b MyVariant field, which in turn will try to perform read operation
/// on @b Property1, @b Property2, and @b Property3 in the order of their 
/// definition inside the provided tuple. The read operation of the
/// comms::field::Variant field type will stop when read operation of any
/// of the contained types reports comms::ErrorStatus::Success as its status.
/// That's why every @b key field needs to fail its @b read operation on
/// invalid value.
///
/// The extension of the key/value pairs example above to 
/// TLV triplets is quite easy.
/// @code
/// // No need for length prefix for strings any more
/// using Value3 = comms::field::String<MyFieldBase>;
/// ...
/// template <typename TKey, typename TValue>
/// class Property : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             TKey,
///             comms::field::IntValue<MyFieldBase, std::uint16_t>, // 2 byte value of remaining length
///             TValue
///         >,
///         comms::option::def::RemLengthMemberField<1> // Index of remaining length field is 1
///     >
/// {
///     using Base = ...; // repeat base definition
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(key, length, value);
/// };
/// @endcode
/// @b NOTE usage of @ref comms::option::def::RemLengthMemberField option described
/// earlier in @ref sec_field_tutorial_bundle section. It informs the @b COMMS
/// library about presence of the @b length value in the bundle, which will result
/// in proper read length limitation for the value(s) to follow. Also in case
/// the read of the following value(s) does not consume all the reported length, 
/// @b COMMS library will advance the read iterator to consume the remaining
/// bytes resulting in read of the next field to be at correct location.
///
/// The @b length field in example above contains @b remaining length 
/// not including the field itself. Some protocols may include the length of
/// the @b length field itself. If this is the case, just use 
/// @ref comms::option::def::NumValueSerOffset option 
/// (described in @ref sec_field_tutorial_int_value_ser_offset) 
/// to add extra numeric offset to 
/// be added when the field's value is written.
/// @code
/// template <typename TKey, typename TValue>
/// class Property : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             TKey,
///             comms::field::IntValue<
///                 MyFieldBase, 
///                 std::uint16_t, 
///                 comms::option::def::NumValueSerOffset<sizeof(std::uint16_t)> 
///             >, // 2 byte value of remaining length
///             TValue
///         >,
///         comms::option::def::RemLengthMemberField<1> // Index of remaining length field is 1
///     >
/// {
///     using Base = ...; // repeat base definition
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(key, length, value);
/// };
/// @endcode
///
/// @b RECOMMENDATION: In case of @b TLV property triplets it is recommended
/// to create a dummy field with non-failing read to allow usage of unknown
/// properties which can be introduced in later versions of the protocol.
/// @code
/// class UnknownProperty : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::IntValue<MyFieldBase, std::uint8_t>, // storage of unknown key
///             comms::field::IntValue<MyFieldBase, std::uint16_t>, // 2 byte value of remaining length
///             comms::field::ArrayList<MyFieldBase, std::uint8_t>, // storage or raw data
///         >,
///         comms::option::def::RemLengthMemberField<1> // Index of remaining length field is 1
///     >
/// {
///     using Base = ...; // repeat base definition
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(key, length, value);
/// };
/// @endcode
/// And put such property at the end of the supported types tuple for the variant field definition.
/// @code
/// struct MyVariant : public 
///     comms::field::Variant<
///         MyFieldBase,
///         std::tuple<Property1, Property2, Property3, UnknownProperty>
///     >
/// {
///     ...
/// };
/// @endcode 
/// The default constructed comms::field::Variant object from the examples above 
/// has an "invalid" state, i.e. hasn't been initialized and doesn't contain any
/// valid field. It can be changed by providing @ref comms::option::def::DefaultVariantIndex
/// option.
/// @code
/// struct MyVariant : public 
///     comms::field::Variant<
///         MyFieldBase,
///         std::tuple<Property1, Property2, Property3>,
///         comms::option::def::DefaultVariantIndex<0> // Initialise as Prop1
///     >
/// {
///     COMMS_VARIANT_MEMBERS_NAMES(prop1, prop2, prop3);
/// };
/// @endcode 
/// When instantiating such @b MyVariant object, there is no need to perform
/// initialization (construction) of the contained object.
/// @code
/// MyVariant var;
/// assert(var.currentFieldValid());
/// assert(var.currentField() == 0U); // Make sure the current index is 0
/// auto& prop1 = var.accessField_prop1(); // Get access to Property1 interface
/// ...
/// @endcode
/// <b>SIDE NOTE:</b> In addition to @ref COMMS_VARIANT_MEMBERS_NAMES() macro
/// there is @ref COMMS_VARIANT_MEMBERS_ACCESS() one. It is very similar to
/// @ref COMMS_VARIANT_MEMBERS_NAMES() but does @b NOT (re)define the inner @b Field_*
/// types. It also does not require (except for @b clang) having base class to
/// be (re)defined as inner @b Base type.
/// @code
/// class MyVariant : public comms::field::Variant<...>
/// {
/// public:
///     COMMS_VARIANT_MEMBERS_ACCESS(prop1, prop2, prop3);
/// }
/// @endcode
/// In fact @ref COMMS_VARIANT_MEMBERS_NAMES() is implemented as the wrapper 
/// around @ref COMMS_VARIANT_MEMBERS_ACCESS().
/// 
/// @section sec_field_tutorial_common_options Common Options or Modifications for the Fields
/// There are options that suitable only to numeric fields, such as 
/// comms::field::IntValue, comms::field::EnumValue, comms::field::BitmaskValue. @n
/// There are options that suitable only for collection fields, such as
/// comms::field::ArrayList, and comms::field::String.@n
/// There are also @b common options that can be used with all the fields that support
/// options.
///
/// @subsection sec_field_tutorial_common_options_default_value Default Value for Default Construction
/// There may be a case when default construction of the field object should
/// assign some custom value to the field, which differ to the usual defaults, such
/// as assigning 0 to numeric fields or empty string to a string field. 
/// 
/// One of the possible ways is to extend the defined field class and 
/// set the required value in the constructor.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// struct MyString : public comms::field::String<MyFieldBase>
/// {
///     MyString()
///     {
///         value() = "hello";
///     }
/// };
/// @endcode
/// Another way is to use comms::option::def::DefaultValueInitialiser option.
/// It receives a template parameter, which has to be a type of initialisation
/// class. It must provide @b operator() which is responsible to assign a custom
/// value to the field. It is going to be invoked from the default constructor
/// of the field.
/// @code
/// struct Initaliser
/// {
///     template <typename TField>
///     void operator()(TField& field)
///     {
///         field.value() = ...; // Set the default value here
///     }
/// };
/// @endcode
/// For example:
/// @code
/// struct CustomStringInitaliser
/// {
///     template <typename TField>
///     void operator()(TField& field)
///     {
///         field.value() = "hello"
///     }
/// };
///
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyString = 
///     comms::field::String<
///         MyFieldBase, 
///         comms::option::def::DefaultValueInitialiser<CustomStringInitaliser> 
///     >;
///
/// MyString myStr; // Default construction
/// assert(myStr.value() == "hello"); // Custom default value is expected to be assigned
/// @endcode
/// @b NOTE that the used @b operator() specifies the field type as a template
/// parameter. This is required because the passed reference is to one of the
/// defined field's base classes, which is implementation dependent. Just use
/// the provided @b value() member function to access the value.
///
/// The COMMS library also provides a simpler alias for @ref comms::option::def::DefaultValueInitialiser
/// to set default value for numeric fields. It is @ref comms::option::def::DefaultNumValue.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyInt = 
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t,
///         comms::option::def::DefaultNumValue<10> 
///     >;
/// 
/// MyInt myInt;
/// assert(myInt.value() == 10); // Custom default value is expected to be assigned
/// @endcode
///
/// @subsection sec_field_tutorial_common_options_read Custom Read Functionality
/// Every field provides @b read() member function to perform read of the field's
/// value. Sometimes the default "read" functionality may be incorrect or
/// incomplete. For example, let's
/// define a "bundle" field with two members. The first one is a "bitmask", while
/// the second one is optional 2 byte "int" value. The second member exists 
/// only if least significant bit of the "bitmask" is not @b 0. In this case, 
/// the provided @b read() member function won't analyse the value of the
/// read "bitmask" and won't modify "existing"/"missing" mode value of the
/// optional field.
///
/// One way to implement custom read functionality is to extend the field
/// definition and override the @b read() member function:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// class MyBundle : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> >,
///             comms::field::Optional<MyFieldBase, std::uint16_t>
///         >,
///         comms::option::def::HasCustomRead
///     >
/// {
///     using Base = comms::field::Bundle<...>;
/// public:
///     // Provide convenience access functions    
///     COMMS_FIELD_MEMBERS_NAMES(mask, value);
///    
///     template <typename TIter>
///     comms::ErrorStatus read(TIter& iter, std::size_t len)
///     {
///         using Base = typename std::decay<decltype(comms::field::toFieldBase(*this))>::type;
///         
///         auto es = Base::template readUntilAndUpdateLen<FieldIdx_value>(iter, len);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         if (field_mask().getBitValue(0)) {
///             field_value().setExists();
///         }
///         else {
///             field_value().optInt.setMissing();
///         }
///
///         return Base::template readFrom<FieldIdx_value>(iter, len)
///     }
/// };
/// @endcode
/// Please @b NOTE the following:
/// @li Usage of @ref comms::option::def::HasCustomRead option. It notifies
/// other classes about existence of custom @b read functionality 
/// (instead of default one). Other classes may contain some inner logic to
/// perform various optimisations if there is no custom @b read.
/// Failure to specify this option may result in incorrect behaviour.
/// @li If @b Base type is not specified manually, then it can be obtained using 
/// @ref comms::field::toFieldBase(). function.
/// @li The @ref comms::field::Bundle class has set of member functions for partial 
/// reads. Thise operations can be either non-modifying input length parameter 
/// (@ref comms::field::Bundle::readFrom(), @ref comms::field::Bundle::readUntil(), 
/// and @ref comms::field::Bundle::readFromUntil()) or modifying 
/// (@ref comms::field::Bundle::readFromAndUpdateLen(), @ref comms::field::Bundle::readUntilAndUpdateLen(), 
/// and @ref comms::field::Bundle::readFromUntilAndUpdateLen()). The latter
/// can be used to automatically reduce remaining length value.
///
/// Another way is to use @ref comms::option::def::CustomValueReader option. It
/// receives one template parameter, which has to be a type of a custom
/// reader class. Such class must implement @b operator() with the following
/// signature:
/// @code
/// struct MyReader
/// {
///     template <typename TField, typename TIter>
///     comms::ErrorStatus operator()(TField& field, TIter& iter, std::size_t len) const
///     {
///         ... // Do proper read of the field's value.
///     }
/// };
/// @endcode
/// @b NOTE that the used @b operator() specifies the field type as a template
/// parameter. This is required because the passed reference is to one of the
/// defined field's base classes, which is implementation dependent. Just use
/// the provided @b value() member function to access the tuple of member fields.
/// 
/// @subsection sec_field_tutorial_common_options_validation Custom Value Validation Logic
/// Every field provides @b valid() member function to validate the internal value.
/// By default, every internal value of the field is considered to be valid, i.e.
/// the @b valid() function will always return true. 
///
/// One of the ways to provide custom validation logic is to extend the field
/// definition and implement @b valid() member function:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// struct MyString : public comms::field::String<MyFieldBase>
/// {
///     bool valid() const
///     {
///         // Valid if not empty and starts with '$'
///         return (!value().empty()) && (value()[0] == '$');
///     }
/// };
/// @endcode
/// 
/// Another way is to use @ref comms::option::def::ContentsValidator option. It
/// receives one template parameter, which has to be a type of a custom
/// validator class. Such class must implement @b operator() with the following
/// signature:
/// @code
/// struct MyValidator
/// {
///     template <typename TField>
///     bool operator()(const TField& field)
///     {
///         auto& value = field.value();
///         return (... /* Check value */); // return true if valid.
///     }
/// };
/// @endcode
/// For example:
/// @code
/// struct CustomStringValidator
/// {
///     template <typename TField>
///     bool operator()(const TField& field)
///     {
///         // Valid if not empty and starts with '$'
///         auto& str = field.value();
///         return (!str.empty()) && (str[0] == '$');
///     }
/// };
///
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyString = comms::field::String<
///     MyFieldBase, 
///     comms::option::def::ContentsValidator<CustomStringValidator> 
///  >;
///
/// MyString myStr; 
/// assert(!myStr.valid()); // Default construction creates empty string - invalid
/// 
/// myStr.value() = "$somestring";
/// assert(myStr.valid()); // Now the string is as expected
/// @endcode
/// @b NOTE that the used @b operator() specifies the field type as a template
/// parameter. This is required because the passed reference is to one of the
/// defined field's base classes, which is implementation dependent. Just use
/// the provided @b value() member function to access the value.
///
/// Quite often the valid values of the numeric fields can be expressed in limited
/// number of ranges: [minValid - maxValid]. The COMMS library provides 
/// @ref comms::option::def::ValidNumValueRange option (and @ref comms::option::def::ValidNumValue alias),
/// which can be used multiple times. The field's value is considered to be valid if
/// <b>at least one</b> of the provided ranges contains it. The range validation option
/// can be used only with numeric value fields, such as comms::field::IntValue, 
/// or comms::field::EnumValue. For example:
/// @code
/// enum SomeEnum : std::uint8_t
/// {
///     SomeEnum_Value1 = 1,
///     SomeEnum_Value2,
///     SomeEnum_Value3
/// };
///
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyEnum = 
///     comms::field::EnumValue<
///         MyFieldBase, 
///         SomeEnum,
///         comms::option::def::DefaultNumValue<SomeEnum_Value1>, // Construct with valid value
///         comms::option::def::ValidNumValueRange<SomeEnum_Value1, SomeEnum_Value3>
///     >;
///
/// MyEnum myEnum;
/// assert(myEnum.value() == SomeEnum_Value1);
/// assert(myEnum.valid());
///
/// myEnum.value() = static_cast<SomeEnum>(0); // Assigning invalid value.
/// assert(!myEnum.valid()); // The field being invalid must be reported
/// @endcode
///
/// Another example could be a single character numeric field with valid values
/// range of [0x20 - 0x7e], as well as value 0. Such field can be defined as:
/// @code
/// using MyChar = 
///     comms::field::IntValue<
///         MyFieldBase,
///         char,
///         comms::option::def::ValidNumValueRange<0x20, 0x7e>,
///         comms::option::def::ValidNumValue<0>
///     >;
/// @endcode
/// @b WARNING: Some older compilers (@b gcc-4.7) fail to compile valid C++11 code
/// that allows usage of multiple @ref comms::option::def::ValidNumValueRange options. If this is
/// the case, please don't pass more than one @ref comms::option::def::ValidNumValueRange option.
///
/// There is a also a convenience alias to @ref comms::option::def::ContentsValidator intended
/// for use with bitmasks (comms::field::BitmaskValue). Many bitmask fields
/// may have one or several reserved bits with predefined values they must contain.
/// The alias option is @ref comms::option::def::BitmaskReservedBits. It receives two 
/// template parameters: one for the mask indicating the reserved bits and another
/// for the expected values of these bits.@n
/// For example, below is a definition of the 1 byte bitmask field that has
/// two reserved bits, most and least significant. Both of them must be 0.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyFlags = 
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x81, 0>
///     >;
///
/// MyFlags flags;
/// assert(myEnum.valid());
/// flags.value() |= 0x1; // set bit 0;
/// assert(!flags.valid()); // the field is invalid now.
/// @endcode
///
/// @subsection sec_field_tutorial_common_options_refresh Custom Refresh Functionality
/// Every field provides @b refresh() member function used to bring the field's 
/// value into a consistent state. By default this function does nothing and
/// returns @b false, meaning the field has @b NOT been updated. For complex fields, such
/// as comms::field::Bitfield or comms::field::Bundle, the default behaviour is
/// to invoke @b refresh() member function of each member field and return @b true
/// if @b any of the calls returned true.
///
/// One way to change such default behaviour is to extend the field
/// definition and implement @b refresh() member function. Let's take the
/// same example as in @ref sec_field_tutorial_common_options_read section. There is
/// a "bundle" field with two members. The first one is a "bitmask", while
/// the second one is optional 2 byte "int" value. The second member exists 
/// only if least significant bit of the "bitmask" is not @b 0. There is a 
/// chance of having inconsistent state when the least significant bit in
/// the "bitmask" is set, but the optional "int" field is marked to be "missing".
/// There is a need to provide the custom "refresh" logic that brings the field's
/// contents into a consistent state.
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// struct MyBundle : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> >,
///             comms::field::Optional<MyFieldBase, std::uint16_t>
///         >,
///         comms::option::def::HasCustomRead,
///         comms::option::def::HasCustomRefresh
///     >
/// {
///     ... 
///
///     bool refresh()
///     {
///         auto expectedMode = comms::field::OptionalMode::Missing;
///         if (field_mask().getBitValue(0)) {
///             expectedMode = comms::field::OptionalMode::Exists;
///         }
///
///         if (field_value().getMode() == expectedMode) {
///             return false; // Nothing has been changed
///         }
///     
///         field_value().setMode(expectedMode);
///         return true; // Field has been updated
///     }
/// };
/// @endcode
/// @b NOTE the usage of @ref comms::option::def::HasCustomRefresh option. It notifies
/// other classes about existence of custom @b refresh functionality 
/// (instead of default one). Other classes may contain some inner logic to
/// perform various optimisations if there is no custom @b refresh.
/// Failure to specify this option may result in incorrect behaviour.
/// 
/// Another way is to use comms::option::def::ContentsRefresher option. It
/// receives one template parameter, which has to be a type of a custom
/// refresher class. Such class must implement @b operator() with the following
/// signature:
/// @code
/// struct MyRefresher
/// {
///     template <typename TField>
///     bool operator()(TField& field)
///     {
///         ... // return true if field was modified, false otherwise
///     }
/// };
/// @endcode
/// @b NOTE that the used @b operator() specifies the field type as a template
/// parameter. This is required because the passed reference is to one of the
/// defined field's base classes, which is implementation dependent. Just use
/// the provided @b value() member function to access the value.
///
/// @subsection sec_field_tutorial_common_options_write Custom Write Functionality
/// On some very rare occasions there may be a need to write custom @b write
/// functionality. It can be achieved by writing custom @b write() member function
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// struct MyBundle : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<...>,
///         comms::option::def::HasCustomWrite
///     >
/// {
///     template <typename TIter>
///     comms::ErrorStatus write(TIter& iter, std::size_t len) const
///     {
///         ...
///     }
/// };
/// @endcode
/// @b NOTE usage of @ref comms::option::def::HasCustomWrite option. It is 
/// required to let prevent field holding @ref comms::MessageBase
/// class from attempting to optimize write operation due to possible incorrect
/// behavior.
///
/// @subsection sec_field_tutorial_common_options_version Custom Version Update Functionality
/// Some protocols may include version information either in the transport framing
/// of every message or in one of the messages used to establish connection. Such
/// info may influence whether some fields exist, as well as modify other
/// aspects of the fields, such as validity ranges. 
///
/// Every field provides @b setVersion() member function used to notify it about
/// the version change and @b isVersionDependent() one to inquire at compile time
/// whether the field contents may change after such notification. 
/// For most fields @b setVersion() function does nothing and
/// returns @b false, meaning the field has @b NOT been updated (similar to
/// @ref sec_field_tutorial_common_options_refresh). For complex fields, such
/// as comms::field::Bitfield or comms::field::Bundle, the default behaviour is
/// to invoke @b setVersion() member function of each member field and return @b true
/// if @b any of the calls returned @b true. For @ref comms::field::ArrayList
/// fields, the version information may be stored inside (only if the element's
/// @b isVersionDependent() member function returns @b true) and used to notify
/// every new field that is being read during @b read operation.
///
/// Usually, the default version handling provided by the @b COMMS library is
/// good enough. However, there may be cases when custom operation needs to
/// be performed during version update. For example, there is integral value
/// field with valid values range [0, 5]. There is a need to report field as
/// being invalid for any other numbers for all version up to @b 5. However, since
/// version @b 6 the range is extended to [0, 10]. It can be defined as following:
/// @code
/// class MyInt : public
///     comms::field::IntValue<
///         MyFieldBase,
///         std::uint8_t,
///         comms::option::def::ValidNumValueRange<0, 5>,
///         comms::option::def::HasCustomVersionUpdate
/// {
///     using Base = comms::field::IntValue<...>; // Repeat base class definition
/// public:
///     // Updated validity check
///     bool valid() const
///     {
///         if (Base::valid()) {
///             return true;
///         }
///         
///         if (m_version < 6) {
///             return false;
///         }
///
///         return value() <= 10;
///     }
///
///     // Updated version set
///     // Store version internally for future references
///     bool setVersion(VersionType version)
///     {
///         m_version = version;
///         return Base::setVersion(version);
///     }
///
/// private:
///     VersionType m_version = 0;
/// };
/// @endcode
/// @b NOTE, the usage of @ref comms::option::def::HasCustomVersionUpdate option. It
/// marks the defined field as "version dependent" and as the result its @b
/// isVersionDependent() member function will return @b true.
///
/// Also @b NOTE, that by default the @b VersionType inner type is defined to
/// be @b unsigned. If there is a need to change that, the @ref
/// comms::option::def::VersionType needs to be passed to the definition of the 
/// common base class of all the fields:
/// @code
/// using MyFieldBase = 
///     comms::Field<
///         comms::option::def::BigEndian,
///         comms::option::def::VersionType<unsigned long long>
///     >;
/// @endcode
///
/// @subsection sec_field_tutorial_common_options_fail_invalid Fail on Invalid Value
/// Sometimes the protocol specifications may impose a strict rules on disallowing
/// invalid values, such as the message must be dropped when some field has
/// an invalid value. It is easy to implement by forcing @b read() operation on
/// such field to fail when reading an invalid value is recognised. The COMMS
/// library provides comms::option::def::FailOnInvalid option to help with such task.
/// For example:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyField = 
///     comms::field::IntValue<
///         MyFieldBase,
///         std::uint8_t,
///         comms::option::def::ValidNumValueRange<0, 5>,
///         comms::option::def::FailOnInvalid
///     >;
///
/// static const std::uint8_t InvalidBuf[] = { 0x6 };
/// static const auto InvalidBufSize = std::extent<decltype(InvalidBuf)>::value;
///
/// MyField myField;
/// auto* readIter = &InvalidBuf[0];
/// auto es = myField.read(readIter, InvalidBufSize);
/// assert(es != comms::ErrorStatus::Success); // Read failure is expected
///
/// static const std::uint8_t ValidBuf[] = { 0x1 };
/// static const auto ValidBufSize = std::extent<decltype(ValidBuf)>::value;
///
/// readIter = &ValidBuf[0];
/// es = myField.read(readIter, ValidBufSize);
/// assert(es == comms::ErrorStatus::Success); // Read operation is expected to be successful now
/// @endcode
///
/// @subsection sec_field_tutorial_common_options_ignore_invalid Ignore Invalid Value
/// The COMMS library also provides @ref comms::option::def::IgnoreInvalid option. It DOESN'T
/// report failure on read operation when the invalid value is discovered 
/// (like @ref comms::option::def::FailOnInvalid does). Instead the field's internal value
/// remains unchanged, although the read iterator is advanced as if the value
/// is read. For example:
/// @code
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using MyField = comms::field::IntValue<
///     MyFieldBase,
///     std::uint8_t,
///     comms::option::def::ValidNumValueRange<0, 5>,
///     comms::option::def::IgnoreInvalid
/// >;
///
/// static const std::uint8_t InvalidBuf[] = { 0x6 };
/// static const auto InvalidBufSize = std::extent<decltype(InvalidBuf)>::value;
///
/// MyField myField;
/// assert(myField.valid());
/// assert(myField.value() == 0U);
///
/// auto* readIter = &InvalidBuf[0];
/// auto es = myField.read(readIter, InvalidBufSize);
/// assert(es == comms::ErrorStatus::Success); // No failure is expected
/// assert(myField.value() == 0U); // Value mustn't be changed
///
/// static const std::uint8_t ValidBuf[] = { 0x1 };
/// static const auto ValidBufSize = std::extent<decltype(ValidBuf)>::value;
///
/// readIter = &ValidBuf[0];
/// es = myField.read(readIter, ValidBufSize);
/// assert(es == comms::ErrorStatus::Success); // No failure is expected
/// assert(myField.value() == 1U); // Value is expected to be updated
/// @endcode
///
/// @subsection sec_field_tutorial_common_options_empty_ser Empty Serialisation
/// Some protocols may define some constants which are NOT being sent over I/O
/// link. Sometimes it may be useful to still treat these values as message fields.
/// Usage of @ref comms::option::def::EmptySerialization (or @ref 
/// comms::option::def::EmptySerialisation for those who prefer British spelling) can
/// be used to achieve such effect.
/// @code
/// using MyField = comms::field::IntValue<
///     MyFieldBase,
///     std::uint8_t,
///     comms::option::def::ValidNumValueRange<5, 5>,
///     comms::option::def::DefaultNumValue<5>,
///     comms::option::def::EmptySerialization
/// >;
/// 
/// MyField field;
/// assert(field.length() == 0U); // Not expected to have any serialisation length
/// assert(field.value() == 5U); // The value is still accessible;
///
/// std::vector<std::uint8_t> outBuf;
/// auto writeIter = std::back_inserter(outBuf);
/// auto es == field.write(writeIter, outBuf.max_size());
/// assert(es == comms::ErrorStatus::Success); // No failure is expected
/// assert(outBuf.empty()); // No data has been written
/// @endcode
///
/// @section sec_field_tutorial_extension Allowing Further Use of Options
/// As was mentioned earlier there are options that define how fields are
/// (de)serialised. These options are expected to be used in protocol fields 
/// definition. However, there are options that are application specific. They
/// may change the data structures being used for storage, or modify default
/// value and/or valid values. In order to allow such application specific modifications,
/// the defined fields should allow further extension, for example with extra
/// variadic template arguments.
/// @code
/// template <typename... TExtraOpts>
/// using MyField = 
///     comms::field::IntValue<
///         comms::Field<comms::option::def::BigEndian>, // base class of the field
///         std::uint16_t,
///         TExtraOpts...,
///         comms::option::def::DefaultNumValue<5>,
///         comms::option::def::ValidNumValueRange<5, 1000>
/// @endcode
/// Please @b note, that current implementation gives preference to the options
/// defined @b earlier. That's why @b TExtraOpts... should be listed before any
/// other options. It will allow setting other default value needed by the application,
/// and/or override the valid values ranges (using @ref comms::option::def::ValidRangesClear).
/// For example:
/// @code
/// using MyUpdatedField = 
///     MyField<
///         comms::option::def::DefaultNumValue<10>,
///         comms::option::def::ValidNumValueRange<10, 500>,
///         comms::option::def::ValidRangesClear
///     >
/// @endcode
///
/// @section sec_field_tutorial_custom_fields Custom Fields
/// There may be a case when communication protocol demands implementation of
/// some intricate field's logic that is not covered by the COMMS library. It 
/// is possible to provide custom implementation of the custom field and use
/// it with other components provided by the library as long as it defines 
/// the following minimal interface:
/// @code
/// class MyField
/// {
/// public:
///     
///     // Length required to serialise current value 
///     std::size_t length() const;
///
///     // Minimal length required to serialise any value this field may contain
///     static constexpr std::size_t minLength();
///
///     // Maximal length required to serialise any value this field may contain.
///     static constexpr std::size_t maxLength();
///
///     // Check validity of the internal value
///     bool valid() const;
///
///     // Bring field's value into the consistent state,
///     // return true if the field's value has been updated, false otherwise
///     bool refresh();
///
///     // Read field value from input data sequence, using any type of input iterator
///     template <typename TIter>
///     comms::ErrorStatus read(TIter& iter, std::size_t size);
///
///     // Write field value to output data sequence, using any type of output iterator
///     template <typename TIter>
///     comms::ErrorStatus write(TIter& iter, std::size_t size) const;
/// };
/// @endcode
/// The comms::Field class provides @b readData() and @b writeData() protected
/// member functions that serialise data using endian provided as an option
/// to the class. It makes sense to inherit from comms::Field with right
/// option and reuse these functions inside:
/// @code
/// class MyField : public comms::Field<comms::option::def::BigEndian>
/// {
/// public:
///     
///     ...
/// 
///     template <typename TIter>
///     comms::ErrorStatus read(TIter& iter, std::size_t size)
///     {
///         ...
///         auto val = readData<InternalType>(iter);
///         ...
///     }
///
///     template <typename TIter>
///     comms::ErrorStatus write(TIter& iter, std::size_t size) const
///     {
///         ...
///         writeData(..., iter);
///         ...
///     }
/// };
/// @endcode
/// Also to be consistent with the existing implementation of the fields
/// in the COMMS library it is recommended to provide an accessor functions
/// @b value() for internal data storage:
/// @code
/// class MyField : public comms::Field<comms::option::def::BigEndian>
/// {
/// public:
///     using ValueType = ...;
/// 
///     ValueType& value() {...}
///
///     const ValueType& value() const {...}
/// };
/// @endcode
///
/// @section sec_field_tutorial_other_fields Other Fields
/// With time the COMMS library may grow by adding support for some other
/// built-in fields as well as supporting extra options to the existing
/// fields described in this tutorial. If such new field and/or option is
/// not described in this tutorial, it should be easy enough for the developer
/// to master. Please refer to the documentation of the field and/or option 
/// itself.
///

